<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF346D Robot Control</title>
    <url>/2021/11/07/CF346D-Robot-Control/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/CF346D">CF346D Robot Control</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以想到，对于每一个节点，$dp[x]$ 表示其走到终点所需的最少指令数。考虑状态的转移：如果下指令，则 $dp[i]$ 为其出边所通向的点中的最小值加一。若不下指令则取最大值，两种情况取最小值。即，<br>$$<br>dp[x]=\min\{\min_{x\to y}\{dp[y]\}+1,\max_{x\to y}\{dp[y]\}\}<br>$$<br><strong>你能解决问题的一部分吗？</strong></p>
<p>可以发现下指令的部分类似于一个边权为 $1$ 的最短路，尝试用 $BFS$ 解决。我们先对 $BFS$ 的过程进行一下概括，$BFS$ 时队列中的元素如下：</p>
<p><img src="/2021/11/07/CF346D-Robot-Control/1.png" alt="pic1"></p>
<p>可以发现，队列中元素（指 $dp$ 值）总是连续的 $n$ 和 $n+1$，且不降。在反图上 $BFS$，每次取队首元素进行更新，从队尾插入。</p>
<p>再考虑不钦定前进方向的情况。（称“第二类”）</p>
<p>枚举 $x$ 的所有出边（在原图上），如果发现指向的点的 $dp$ 值的最大值小于 $dp[x]$，则更新，同时在队首插入 $x$ 以保证单调性在 $x$ 出队时，如果 $x$ 能被第二类更新，显然它应该先被更新再更新别的点，这样不会在非最优值上浪费时间，而此时第二类更新 $x$ 的点一定已经被更新，因此 $x$ 一出队就对其更新，时间复杂度正确，而正确性显然。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>],n,m,t[<span class="number">1000001</span>],tt[<span class="number">1000001</span>],S,T;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span></span><br><span class="line">&#123;<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;edge[<span class="number">2000010</span>],egde[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> que[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> emp (l&gt;r)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L que[l]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop vis[que[l++]]=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pl(x) vis[x]=1,que[--l]=x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) vis[x]=1,que[++r]=x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to1 edge[i].to</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to2 egde[i].to</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt1].to=u;</span><br><span class="line">	edge[cnt1].nxt=t[v];</span><br><span class="line">	t[v]=cnt1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	egde[++cnt2].to=u;</span><br><span class="line">	egde[cnt2].nxt=tt[v];</span><br><span class="line">	tt[v]=cnt2;</span><br><span class="line"><span class="comment">//	++deg[v];</span></span><br><span class="line">&#125;<span class="comment">//反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="meta">#<span class="keyword">ifdef</span> usm</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">		<span class="built_in">Add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;S,&amp;T);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	l=<span class="number">1000001</span>,r=<span class="number">1000000</span>;</span><br><span class="line">	dp[T]=<span class="number">0</span>;</span><br><span class="line">	que[++r]=T;</span><br><span class="line">	<span class="keyword">while</span>(!emp)<span class="comment">//BFS</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> _=L;</span><br><span class="line">		pop;</span><br><span class="line">		<span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t[_];i;i=edge[i].nxt)<span class="keyword">if</span>(dp[to1]&gt;mx)</span><br><span class="line">				mx=dp[to1];</span><br><span class="line">		<span class="keyword">if</span>(dp[_]&gt;mx)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[_]=mx;</span><br><span class="line">			<span class="keyword">if</span>(!vis[_])<span class="built_in">pl</span>(_);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=tt[_];i;i=egde[i].nxt)</span><br><span class="line">		<span class="keyword">if</span>(dp[_]+<span class="number">1</span>&lt;dp[to2])</span><br><span class="line">		&#123;</span><br><span class="line">			dp[to2]=dp[_]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!vis[to2])</span><br><span class="line">				<span class="built_in">pr</span>(to2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dp[S]!=inf)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[S]);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>Burnside 引理与 Polya 定理</title>
    <url>/2021/10/31/Burnside-%E5%BC%95%E7%90%86%E4%B8%8E-Polya-%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><ol>
<li><p>置换：置换是一个集合映至自身的双射。$(a_1,a_2,\cdots,a_n)$ 表示将原数列的第 $a_i$ 个数在此置换作用下变到第 $i$ 个位置。</p>
</li>
<li><p>对于状态 $s$ 和置换 $f$，记 $f*s$ 为将 $f$ 作用于 $s$ 所得到的状态。</p>
</li>
<li><p>定义置换的乘法：$f\cdot g$ 表示显作用 $g$ 再作用 $f$。</p>
</li>
<li><p>置换群：有限集合上的一些置换组成的集合在置换的乘法下组成的群。</p>
</li>
<li><p>等价类：若状态组成的集合 $X$ 中的元素经过置换群 $G$ 中的置换作用后可以变成相同的状态，则这些状态属于一个等价类。等价类组成的集合记为 $X/G$。</p>
</li>
<li><p>循环：如果一个置换 $f=(a_1,a_2,\cdots,a_n)$，存在 $k$ 个元素使得 $a_{x_1}=x_2,a_{x_2}=x_3,\cdots,a_{x_k}=x_1$，则称 $x_1,x_2,\cdots,x_k$ 为一个长度为 $k$ 的循环。一个置换可以被拆分为一些不相交的循环，如：<br>$$<br>(6,5,7,4,1,2,3)=(1,6,2,5)\circ(3,7)\circ(4)<br>$$</p>
</li>
<li><p>轨道与稳定子：<br>$$<br>X^{\tau}={s|s\in X,\tau*s=s}<br>$$</p>
<p>$$<br>G(s)={\tau*s|\tau\in G}<br>$$</p>
<p>$G(s)$ 称为 $s$ 的<strong>轨道</strong>。<br>$$<br>G^s={\tau|\tau*s=s}<br>$$<br>$G^s$ 称为 $s$ 的<strong>稳定子</strong>。</p>
</li>
</ol>
<h2 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h2><p>$$<br>\left|X/G\right|=\frac{\sum_{\tau\in G}\left|X^\tau\right|}{\left|G\right|}<br>$$</p>
<p>证明：<br>$$<br>\sum_{\tau\in G}\left|X^\tau\right|=\sum_{\tau\in G}\sum_{s\in X}[\tau*s=s]<br>$$</p>
<p>$$<br>=\sum_{s\in X}\sum_{\tau\in G}[\tau*s=s]=\sum_{s\in X}\left|G^s\right|<br>$$</p>
<p>注意到，$s$ 所在的等价类的大小（记为 $|L_s|$）为 $\tau*s$ 的所有可能结果数。</p>
<p>联想拉格朗日定理，可以猜想：$\left|G^s\right|=\frac{|G|}{|L_s|}$。</p>
<p>首先易证，$G^{s}$ 是 $G$ 的子群。</p>
<p>若 $\alpha,\beta\in G$，$\alpha*s=\beta*s$，</p>
<p>$$<br>\beta^{-1}*(\alpha*s)=\beta^{-1}*(\beta*s)<br>$$</p>
<p>$$<br>(\beta^{-1}\cdot\alpha)*s=s<br>$$</p>
<p>$$<br>\alpha\in aG^s,x,y\in G^s,\alpha=a\cdot x<br>$$</p>
<p>$$<br>\beta^{-1}\cdot\alpha=y,\beta^{-1}\cdot a\cdot x=y,\beta^{-1}\cdot a=y\cdot x^{-1}\in G^s<br>$$</p>
<p>$$<br>\beta\in aG^s<br>$$</p>
<p>则 $\alpha,\beta$ 在同一个 $G^s$ 的左陪集中。<br>$$<br>\alpha,\beta\in aG^s<br>$$</p>
<p>$$<br>x,y\in G^s,\alpha=a\cdot x,\beta=a\cdot y<br>$$</p>
<p>$$<br>\beta^{-1}\cdot\alpha=y^{-1}\cdot a^{-1}\cdot a\cdot x=y^{-1}\cdot x\in G^s<br>$$</p>
<p>$$<br>\alpha*s=\beta*s<br>$$</p>
<p>易得：$\left|G^s\right|=\frac{|G|}{L_s}$<br>$$<br>\sum_{\tau\in G}\left|X^\tau\right|=\sum_{s\in X}\left|G^s\right|=\sum_{s\in X}\frac{|G|}{|L_s|}<br>$$</p>
<p>$$<br>=\sum_{L}\sum_{s\in L}\frac{|G|}{|L|}=|G||X/G|<br>$$</p>
<p>证毕。</p>
<h2 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><p>在染色问题中，如果一个位置可以有 $m$ 种颜色，则记 $c(\tau)$ 为 $\tau$ 中的循环数，则<br>$$<br>\left|X^\tau\right|=m^{c(\tau)}<br>$$</p>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.com.cn/problem/P4980">P4980 【模板】Pólya 定理</a></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ntpr[<span class="number">32000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> prim[<span class="number">10000</span>],nop=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=<span class="number">31621</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ntpr[i])prim[++nop]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;i*prim[j]&lt;=<span class="number">31621</span>&amp;&amp;j&lt;=nop;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ntpr[i*prim[j]])<span class="keyword">break</span>;</span><br><span class="line">            ntpr[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">phi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> _)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret=_;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=nop&amp;&amp;_&gt;<span class="number">1</span>&amp;&amp;prim[i]*prim[i]&lt;=_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(_%prim[i]))ret-=ret/prim[i];</span><br><span class="line">        <span class="keyword">while</span>(!(_%prim[i]))_/=prim[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_&gt;<span class="number">1</span>)ret-=ret/_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> _=x,ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ret*=_,ret%=MOD;</span><br><span class="line">        _=_*_,_=_%MOD;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t,n,ans;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(;t;t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i*i&lt;=n;i++)<span class="keyword">if</span>(!(n%i))ans+=(i*i==n?(<span class="built_in">phi</span>(i)*<span class="built_in">power</span>(n,i<span class="number">-1</span>)):(<span class="built_in">phi</span>(n/i)*<span class="built_in">power</span>(n,i<span class="number">-1</span>)+<span class="built_in">phi</span>(i)*<span class="built_in">power</span>(n,n/i<span class="number">-1</span>))),ans%=MOD;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;phi(442908294)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>OI</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>CF700E Cool Slogans</title>
    <url>/2022/04/12/CF700E-Cool-Slogans/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/CF700E">Link</a></p>
<p>简意：定义字符串等级为出现在其中至少两次的最高等级的子串的等级 +1，空串等级为 0，求给定字符串的等级。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，看到子串的问题，可以想到 SAM。然而任意子串的子串似乎还是不太好表示。在 SAM 上，我们通过边来连接前缀，用 fa 连接后缀。SAM <strong>将子串转化为前缀和后缀</strong>。那么类似地，我们对于某一个子串，先继承它前缀的答案，然后用它的后缀，即 Parent Tree 上的祖先来更新。</p>
<p>在进一步的讨论之前，我们先来讨论一个问题：SAM 上一个节点表示了多个串，我们更新答案时肯定等级越大越好，所以我们存一个节点中最长子串的等级。然而这会不会影响“至少出现两次”？最长的子串没有出现两次，有没有可能有更短的子串出现两次？</p>
<p>我们期望它没有影响。现在来尝试证明它：</p>
<p>如果一个短串（非此节点中最长串）在一个串中两次出现，现在将这个短串向前拓展一位 endpos 一定不变，即任何一个位置上拓展都是可行的。那么如果这是长串的末尾，长串也一定可以拓展出去。</p>
<p>那么我们只需维护每一个节点上最长串的等级。</p>
<p>当我们计算一个节点的等级时，它一定不小于其前缀节点答案最大值。而我们再看它至少出现两次的后缀中等级的最大值，最后取最大值即可。</p>
<p>首先，一个串的等级一定不会比它的后缀小。那么我只需知道，在这个节点的祖先中，保持着其等级在祖先中最大的后缀中最短的那一个是否出现两次即可，很好维护。</p>
<p>那么我们怎么判断是否出现两次呢？</p>
<p>我们发现，一个节点的 endpos 可以通过它儿子的 endpos 之并得到。而我们需要查询的就是一个节点的 endpos 在一个区间中是否出现，那么可以用线段树合并。然而我们是在 Parent Tree 上从下往上求的，而更新的顺序大概上是逆着这个顺序的（不是严格的）。那么还需可持久化一下。</p>
<p>最后，我们按什么顺序更新？为了方便处理，我直接按照了 Maxl 递增的顺序，这样一定是前更新后。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Sam</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ml,fa,ch[<span class="number">26</span>],et,fp;</span><br><span class="line">	&#125;s[<span class="number">400005</span>];<span class="type">int</span> cnt=<span class="number">1</span>,lst=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x=lst;lst=++cnt;s[cnt].ml=s[x].ml+<span class="number">1</span>,s[cnt].et=s[x].et+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(x&amp;&amp;(!s[x].ch[c]))s[x].ch[c]=cnt,x=s[x].fa;</span><br><span class="line">		<span class="keyword">if</span>(!x)</span><br><span class="line">		&#123;</span><br><span class="line">			s[lst].fa=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> y=s[x].ch[c];</span><br><span class="line">		<span class="keyword">if</span>(s[x].ml+<span class="number">1</span>==s[y].ml)</span><br><span class="line">		&#123;</span><br><span class="line">			s[lst].fa=y;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s[++cnt]=s[y],s[cnt].et=<span class="number">0</span>,s[cnt].ml=s[x].ml+<span class="number">1</span>,s[cnt].fa=s[y].fa,s[y].fa=s[lst].fa=cnt;</span><br><span class="line">		<span class="keyword">while</span>(x&amp;&amp;s[x].ch[c]==y)s[x].ch[c]=cnt,x=s[x].fa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[<span class="number">400005</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">400005</span>];</span><br><span class="line"><span class="type">int</span> rt[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,sum;</span><br><span class="line">&#125;t[<span class="number">20000005</span>];<span class="type">int</span> siz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> now=++siz;</span><br><span class="line">	t[now].ls=<span class="built_in">merge</span>(t[u].ls,t[v].ls),t[now].rs=<span class="built_in">merge</span>(t[u].rs,t[v].rs);</span><br><span class="line">	<span class="built_in">upd</span>(now);</span><br><span class="line">	<span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;_,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!_)_=++siz;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span> (<span class="type">void</span>)(t[_].sum=<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;=mid)<span class="built_in">insert</span>(t[_].ls,l,mid,v);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(t[_].rs,mid+<span class="number">1</span>,r,v);</span><br><span class="line">	<span class="built_in">upd</span>(_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rt[x]=<span class="number">0</span>;</span><br><span class="line">	s[x].fp=len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:son[x])</span><br><span class="line">	rt[x]=<span class="built_in">merge</span>(<span class="built_in">build</span>(i),rt[x]),</span><br><span class="line">	s[x].fp=<span class="built_in">min</span>(s[x].fp,s[i].fp);</span><br><span class="line">	<span class="keyword">if</span>(s[x].et)</span><br><span class="line">	&#123;</span><br><span class="line">		s[x].fp=<span class="built_in">min</span>(s[x].fp,s[x].et);</span><br><span class="line">		<span class="built_in">insert</span>(rt[x],<span class="number">1</span>,len,s[x].et);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;L||l&gt;R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)<span class="keyword">return</span> t[x].sum;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(t[x].ls,l,mid,L,R)+</span><br><span class="line">	<span class="built_in">query</span>(t[x].rs,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s[x].ml&lt;s[y].ml;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[<span class="number">400005</span>],up[<span class="number">400005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;a&#x27;</span>||c&gt;<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>((c)&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)<span class="built_in">ad</span>(c-<span class="string">&#x27;a&#x27;</span>),c=<span class="built_in">getchar</span>();</span><br><span class="line">	p[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)son[s[i].fa].<span class="built_in">push_back</span>(i),p[i]=i;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">2</span>,p+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[p[i]]&gt;ans[s[p[i]].fa])</span><br><span class="line">		&#123;</span><br><span class="line">			up[p[i]]=p[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)<span class="keyword">if</span>(s[p[i]].ch[j])ans[s[p[i]].ch[j]]=<span class="built_in">max</span>(ans[s[p[i]].ch[j]],ans[p[i]]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[p[i]].fa==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[p[i]]=<span class="number">1</span>,up[p[i]]=p[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)<span class="keyword">if</span>(s[p[i]].ch[j])ans[s[p[i]].ch[j]]=<span class="built_in">max</span>(ans[s[p[i]].ch[j]],ans[p[i]]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">query</span>(rt[up[s[p[i]].fa]],<span class="number">1</span>,len,s[p[i]].fp-s[p[i]].ml+s[up[s[p[i]].fa]].ml,s[p[i]].fp<span class="number">-1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			up[p[i]]=p[i],ans[p[i]]=ans[s[p[i]].fa]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)<span class="keyword">if</span>(s[p[i]].ch[j])ans[s[p[i]].ch[j]]=<span class="built_in">max</span>(ans[s[p[i]].ch[j]],ans[p[i]]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		up[p[i]]=up[s[p[i]].fa],ans[p[i]]=ans[s[p[i]].fa];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)<span class="keyword">if</span>(s[p[i]].ch[j])ans[s[p[i]].ch[j]]=<span class="built_in">max</span>(ans[s[p[i]].ch[j]],ans[p[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[p[cnt]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Functor and Monad</title>
    <url>/2024/09/22/Functor-and-Monad/</url>
    <content><![CDATA[<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><p>Functor 中定义了 <code>fmap</code> 函数，其功能类似于列表的 <code>map</code>。</p>
<p>其定义如下：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>

<p>可以举几个例子：</p>
<p>列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure>

<p><code>Maybe</code> 类型：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap _ <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">    fmap g (<span class="type">Just</span> x) = <span class="type">Just</span> (g x)</span><br></pre></td></tr></table></figure>

<p>简单来说，<code>fmap</code> 就是对一个 Functor 类型的元素中的值进行统一的操作。</p>
<p><code>fmap</code> 需满足以下条件：</p>
<p>$$<br>\texttt{fmap id = id}<br>$$</p>
<p>$$<br>\texttt{fmap (g . h) = fmap g . fmap h}<br>$$</p>
<h2 id="Applicatives"><a href="#Applicatives" class="headerlink" title="Applicatives"></a>Applicatives</h2><p>Functor 中 <code>fmap</code> 的参数只能是一元函数。而 Applicatives 提供了一种拓展：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">    pure :: a -&gt; f a</span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>

<p>这样，可以得到这样的结果：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">fmap0</span> :: a -&gt; f a</span><br><span class="line"><span class="title">fmap0</span> = pure</span><br><span class="line"></span><br><span class="line"><span class="title">fmap1</span> :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">fmap1</span> g x = pure g &lt;*&gt; x</span><br><span class="line"></span><br><span class="line"><span class="title">fmap2</span> :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line"><span class="title">fmap2</span> g x y = pure g &lt;*&gt; x &lt;*&gt; y</span><br></pre></td></tr></table></figure>

<p>在这里，<code>&lt;*&gt;</code> 类似于 <code>-&gt;</code> 和 <code>$</code>，或者说是一种 Curry 化的方式。</p>
<p>当然，<code>&lt;*&gt;</code> 和 <code>pure</code> 也要满足一定的条件：</p>
<p>$$<br>\texttt{pure id &lt;*&gt; x = x}<br>$$</p>
<p>$$<br>\texttt{pure (g x) = pure g &lt;*&gt; pure x}<br>$$</p>
<p>$$<br>\texttt{x &lt;*&gt; pure y = pure (\g -&gt; g y) &lt;*&gt; x}<br>$$</p>
<p>$$<br>\texttt{x &lt;*&gt; (y &lt;*&gt; z) = (pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z}<br>$$</p>
<p>这些可能没有 Functor 的规则好理解。我们逐一解释：</p>
<ul>
<li><p>$\texttt{pure id &lt;*&gt; x = x}$：保证 <code>id</code> 函数的恒等性质。</p>
</li>
<li><p>$\texttt{pure (g x) = pure g &lt;*&gt; pure x}$：两种 Curry 化传参数的方式对结果没有影响。</p>
</li>
<li><p>$\texttt{x &lt;*&gt; pure y = pure (\g -&gt; g y) &lt;*&gt; x}$：交换参数顺序，函数不变。</p>
</li>
<li><p>$\texttt{x &lt;*&gt; (y &lt;*&gt; z) = (pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z}$：这个是最复杂的一个，我们忽视 <code>f</code> 的存在，尝试用 <code>-&gt;</code> 等来改写这个式子：</p>
<p>$$<br>\texttt{x -&gt; (y -&gt; z) = (x.y) -&gt; z}<br>$$</p>
<p>其实不过是函数复合而已。</p>
</li>
</ul>
<h2 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我们先写出如下代码：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> = <span class="type">Val</span> <span class="type">Int</span> | <span class="type">Div</span> <span class="type">Expr</span> <span class="type">Expr</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">safediv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safediv</span> _ <span class="number">0</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">safediv</span> n m = <span class="type">Just</span> (n `div` m)</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Val</span> n) = <span class="type">Just</span> n</span><br><span class="line"><span class="title">eval</span> (<span class="type">Div</span> x y) = <span class="keyword">case</span> eval x <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Just</span> n -&gt; <span class="keyword">case</span> eval y <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> m -&gt; safediv n m</span><br></pre></td></tr></table></figure>

<p>这段代码是为了解决求解过程中出现除数为零的情况而产生的。然而这段代码一点也不简洁，与创造 Haskell 的大佬的理念不符。我们尝试使用刚刚学过的 Applicative：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Val</span> n) = pure n</span><br><span class="line"><span class="title">eval</span> (<span class="type">Div</span> x y) = pure safediv &lt;*&gt; eval x &lt;*&gt; eval y</span><br></pre></td></tr></table></figure>

<p>这段代码看起来不错，却有类型错误。函数将返回 <code>Maybe (Maybe Int)</code>。</p>
<p>可以看到类型对我们的限制还是很大的，如果不是因为类型错误，这段代码就非常理想了。而 Monad 恰恰可以帮我们解决这个问题：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    return = pure</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b</span></span><br><span class="line">    mx &gt;&gt;= f = <span class="keyword">case</span> mx <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> x -&gt; f x</span><br></pre></td></tr></table></figure>

<p>在这里定义的 <code>&gt;&gt;=</code> 运算符也相当于 <code>$</code> 的作用，即 function application，然而它解决了此过程中 <code>Maybe</code> 的嵌套问题。</p>
<p>那么我们就可以如是定义 <code>eval</code> 函数：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Val</span> n) = <span class="type">Just</span> n</span><br><span class="line"><span class="title">eval</span> (<span class="type">Div</span> x y) = eval x &gt;&gt;= \n -&gt;</span><br><span class="line">                 eval y &gt;&gt;= \m -&gt;</span><br><span class="line">                 safediv n m</span><br></pre></td></tr></table></figure>

<p>而 Monad 还提供了更简洁的实现（语法糖）：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Val</span> n) = <span class="type">Just</span> n</span><br><span class="line"><span class="title">eval</span> (<span class="type">Div</span> x y) = <span class="keyword">do</span> n &lt;- eval x</span><br><span class="line">                    m &lt;- eval y</span><br><span class="line">                    safediv n m</span><br></pre></td></tr></table></figure>

<p>你或许会疑心为什么这与 IO 中的 <code>do</code> 语句如此相似。事实上，IO正是 Monad 的实例：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- return :: a -&gt; IO a</span></span><br><span class="line"><span class="title">return</span> x = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</span></span><br><span class="line"><span class="title">mx</span> &gt;&gt;= f = ...</span><br></pre></td></tr></table></figure>

<p>不过，这两个函数都是植入 Haskell 语言的，并不是通过 Haskell 后定义的，所以这里也没有他们的代码。在这里，当我们写出 <code>c &lt;- getChar()</code> 这样的语句时，我们就将 <code>IO Char</code> 转化成了 <code>Char</code>。</p>
<h3 id="Monad-laws"><a href="#Monad-laws" class="headerlink" title="Monad laws"></a>Monad laws</h3><p>我们同样列出 <code>&gt;&gt;=</code> 需要满足的条件：</p>
<p>$$<br>\texttt{return x &gt;&gt;= f = f x}<br>$$</p>
<p>$$<br>\texttt{mx &gt;&gt;= return = mx}<br>$$</p>
<p>$$<br>\texttt{(mx &gt;&gt;= f) &gt;&gt;= g = mx &gt;&gt;= (\x -&gt; (f x &gt;&gt;= g)) }<br>$$</p>
<h3 id="State-monad"><a href="#State-monad" class="headerlink" title="State monad"></a>State monad</h3><p>现在我们考虑一个问题：用函数描述状态的变化。</p>
<p>首先定义状态，我们以 <code>Int</code> 类型为例，并定义 <em>state transformer</em>（简写 ST）来表示一个对状态进行转化的函数。同时，状态的变化还可能产生结果，我们将这三样东西如下定义：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">State</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">ST</span> = <span class="type">State</span> -&gt; <span class="type">State</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ST</span> a = <span class="type">State</span> -&gt; (<span class="title">a</span>, <span class="type">State</span>) <span class="comment">-- 为了方便后续将其声明为 Monad，我们这里使用 newtype</span></span></span><br></pre></td></tr></table></figure>

<p>另外，我们定义作用函数：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">app</span> :: <span class="type">ST</span> a -&gt; <span class="type">State</span> -&gt; (a, <span class="type">State</span>)</span><br><span class="line"><span class="title">app</span> (<span class="type">S</span> st) x = st x</span><br></pre></td></tr></table></figure>

<p>然后，我们先将其声明为 Functor，然后是 Applicative，最后是 Monad：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">ST</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- fmap :: (a -&gt; b) -&gt; ST a -&gt; ST b</span></span><br><span class="line">    fmap g st = <span class="type">S</span> (\s -&gt; <span class="keyword">let</span> (x, s&#x27;) = app st s <span class="keyword">in</span> (g x, s&#x27;))</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ST</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- pure :: a -&gt; ST a</span></span><br><span class="line">    pure x = (\s -&gt; (x, s))</span><br><span class="line">    <span class="comment">-- &lt;*&gt; = ST (a -&gt; b) -&gt; ST a -&gt; ST b</span></span><br><span class="line">    g &lt;*&gt; st = <span class="type">S</span> (\s -&gt; <span class="keyword">let</span> (g&#x27;, s&#x27;) = app g s, (x, s&#x27;&#x27;) = app st s&#x27; <span class="keyword">in</span> (g&#x27; x, s&#x27;&#x27;))</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">ST</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- (&gt;&gt;=) :: ST a -&gt; (a -&gt; ST b) -&gt; ST b</span></span><br><span class="line">    st &gt;&gt;= f = <span class="type">S</span> (\s -&gt; <span class="keyword">let</span> (x,s&#x27;) = app st s <span class="keyword">in</span> app (f x) s&#x27;)</span><br></pre></td></tr></table></figure>

<p>可以发现，我们定义的 <code>&lt;*&gt;</code> 是先将 <code>g</code> 作用于 <code>s</code> ，然后再用 <code>st</code> 作用于得到的状态。而 <code>&gt;&gt;=</code> 中则正好相反。事实上，<code>&lt;*&gt;</code> 的处理很容易理解，因为这符合我们一个一个传参数的顺序（也可以理解为上面的函数复合规则起的作用）；而</p>
<h3 id="Example-Relabelling-trees"><a href="#Example-Relabelling-trees" class="headerlink" title="Example: Relabelling trees"></a>Example: Relabelling trees</h3><figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Leaf</span> a | <span class="type">Node</span> (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure>

<p>我们现在要给如上定义的树进行重新标号，让每一个叶子节点都有不同的自然数编号。我们写出朴素的方法：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">rlabel</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Int</span> -&gt; (<span class="type">Tree</span> <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">rlabel</span> (<span class="type">Leaf</span> _) n = (<span class="type">Leaf</span> n, n+<span class="number">1</span>)</span><br><span class="line"><span class="title">rlabel</span> (<span class="type">Node</span> l r) n = (<span class="type">Node</span> l&#x27; r&#x27;, n&#x27;&#x27;)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        (l&#x27;,n&#x27;) = rlabel l n</span><br><span class="line">        (r&#x27;,n&#x27;&#x27;) = rlabel r n&#x27;</span><br></pre></td></tr></table></figure>

<p>现在我们用前面介绍的 State Monad 来改进这段代码：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">fresh</span> :: <span class="type">ST</span> <span class="type">Int</span></span><br><span class="line"><span class="title">fresh</span> = <span class="type">S</span> (\n -&gt; (n, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- using the fact that it is an applicative functor</span></span><br><span class="line"><span class="title">alabel</span> :: <span class="type">Tree</span> a -&gt; <span class="type">ST</span> (<span class="type">Tree</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">alabel</span> (<span class="type">Leaf</span> _) = <span class="type">Leaf</span> &lt;$&gt; fresh <span class="comment">-- g &lt;$&gt; x = pure g &lt;*&gt; x</span></span><br><span class="line"><span class="title">alabel</span> (<span class="type">Node</span> l r) = <span class="type">Node</span> &lt;$&gt; alabel l &lt;*&gt; alabel r</span><br><span class="line"></span><br><span class="line"><span class="comment">-- using the fact that it is a monad</span></span><br><span class="line"><span class="title">mlabel</span> :: <span class="type">Tree</span> a -&gt; <span class="type">ST</span> (<span class="type">Tree</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">mlabel</span> (<span class="type">Leaf</span> _) = <span class="keyword">do</span> n &lt;- fresh        </span><br><span class="line">    return (<span class="type">Leaf</span> n)</span><br><span class="line"><span class="title">mlabel</span> (<span class="type">Node</span> l r) = <span class="keyword">do</span> l&#x27; &lt;- mlabel l</span><br><span class="line">    r&#x27; &lt;- mlabel r</span><br><span class="line">    return (<span class="type">Node</span> l&#x27; r&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="Generic-function"><a href="#Generic-function" class="headerlink" title="Generic function"></a>Generic function</h3><p>我们现在在 Monad 上定义一些通用的函数。在 <code>Control.Monad</code> 中提供了此类函数的一些实现。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">mapM</span> :: <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</span><br><span class="line"><span class="title">mapM</span> f [] = return []</span><br><span class="line"><span class="title">mapM</span> f (x:xs) = <span class="keyword">do</span> y &lt;- f x</span><br><span class="line">    ys &lt;- mapM f xs</span><br><span class="line">    return (y:ys)</span><br><span class="line"></span><br><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</span><br><span class="line"><span class="title">join</span> mmx = <span class="keyword">do</span> mx &lt;- mmx        </span><br><span class="line">    x &lt;- mx</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>

<h2 id="范畴论相关"><a href="#范畴论相关" class="headerlink" title="范畴论相关"></a>范畴论相关</h2><h3 id="范畴"><a href="#范畴" class="headerlink" title="范畴"></a>范畴</h3><p>一个范畴 $C$ 由如下资料构成：</p>
<ul>
<li><p>一类对象 $C_0$</p>
</li>
<li><p>一类态射 $C_1$<br>（此处即是说， $C_0, C_1$ 都是类而不一定是集合，譬如 ${s \ |\ s \text{ is a set} }$）</p>
</li>
<li><p>态射上的两个操作 $\text{domain}$ 和 $\text{codomain}$ ，分别将一个态射 $f$ 对应到 $C_0$ 中的一个对象 $\text{dom} f$ 和 $\text{cod} f$</p>
</li>
<li><p>$\text{identity}$ 操作：对任意 $a\in C_0$，定义 $f_{a\to a}\in C$，记为 $1_a$</p>
</li>
<li><p>$\text{composition}$ 操作：$f_{a\to b},g_{b\to c}\in C_1$，定义 $h_{a\to c} = g\circ f$</p>
</li>
</ul>
<p>满足如下公理：</p>
<ul>
<li><p>$f\circ1_a=f=1_b\circ f,\forall f_{a\to b}$</p>
</li>
<li><p>$f\circ(g\circ h)=(f\circ g)\circ h$</p>
</li>
</ul>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>未完待续</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI Online 2022 游记</title>
    <url>/2022/04/09/NOI-Online-2022-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="T1-丹钓战"><a href="#T1-丹钓战" class="headerlink" title="T1 丹钓战"></a><a href="https://www.luogu.com.cn/problem/P8251">T1 丹钓战</a></h2><p>水题，直接单调栈（谐音梗）。</p>
<p>考虑从 $[l,n]$ 转移到 $[l-1,n]$ ，注意到除了 $l$，<strong>只有在前一区间中出现在了栈顶，才有可能在新区间中出现在栈顶</strong>。维护在区间中所有出现在 $S$ 栈顶的元素，考虑 $l-1$ 对其影响：从前至后弹出不能导致 $l-1$ 弹出的元素，直到一个元素弹出了 $l-1$，此后 $l-1$ 对该区间无影响。</p>
<p>在计算到 $[l,n]$ 时，计算出所有 $[l,r]$，维护的是单调的位置序列，$r$ 对序列没有影响，二分 lowerbound 即可。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>$O(n\log n)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxn=<span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[mxn],b[mxn],pos[mxn],ans[mxn];</span><br><span class="line">pair&lt;pii,<span class="type">int</span>&gt; qu[mxn];</span><br><span class="line"><span class="type">int</span> t[mxn],l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(L&lt;=R)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(t[mid]&gt;v)R=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> L=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;stack.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;stack.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	n=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)b[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)qu[i].first.first=-<span class="built_in">read</span>(),qu[i].first.second=<span class="built_in">read</span>(),qu[i].second=i;</span><br><span class="line">	<span class="built_in">sort</span>(qu+<span class="number">1</span>,qu+q+<span class="number">1</span>);l=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n,j=<span class="number">1</span>,an;i&amp;&amp;(j&lt;=q);i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=n&amp;&amp;b[i]&gt;b[t[l]]&amp;&amp;a[t[l]]!=a[i])</span><br><span class="line">		++l;</span><br><span class="line">		t[--l]=i;an=l;</span><br><span class="line">		<span class="keyword">for</span>(;j&lt;=q&amp;&amp;qu[j].first.first==(-i);j++)</span><br><span class="line">		&#123;</span><br><span class="line">			an=<span class="built_in">find</span>(an,n,qu[j].first.second);</span><br><span class="line">			ans[qu[j].second]=an-l+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-讨论"><a href="#T2-讨论" class="headerlink" title="T2 讨论"></a><a href="https://www.luogu.com.cn/problem/P8252">T2 讨论</a></h2><p>假设我们有一个容器，向其中一个一个加入这些集合。</p>
<p>如果两个人会讨论，则一定是后加入那个集合所覆盖的范围一半在一个集合里，一半在集合外。而在出现这种情况之前，两个集合<strong>要么包含，要么交集为空</strong>。</p>
<p>那么如果我构造一种染色方案，使得每一道题，不同的覆盖方案染上不同的颜色，每一次看集合中颜色是否统一不就行了？</p>
<p><del>想得美</del></p>
<p>如果一个集合被该集合真包含，会被误判。</p>
<p>那我就避开这种情况的发生：我按集合大小从大到小排序，那后加入的集合就不可能真包含之前的集合。</p>
<p>那么如何染色呢？</p>
<p>每一次加入一个集合，如果没有被统计答案，则两个集合<strong>要么包含，要么交集为空</strong>，也就是说在这个集合加入的位置上覆盖情况相同。那么我给这个集合所包含的元素染上一个独一无二的颜色。</p>
<p>然后就愉快地结束了（<del>越看越像暴力了</del>）</p>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>多一个集合多一种颜色。给这些点染色或判断是否新加入集合导致讨论是 $O(\sum k_i)$ 的，排序是 $O(n\log n)$ 的，整体复杂度 $O(n\log n+\sum k_i)$。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>经过调整仍丑陋的考场代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k,id;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node n1,node n2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n1.k&gt;n2.k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; mp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">int</span> lst,col[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">bool</span> f1[<span class="number">1000001</span>],f2[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;discuss.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// 	freopen(&quot;discuss.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	T=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(;T;T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="built_in">sizeof</span>(col));</span><br><span class="line">		<span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i].k=<span class="built_in">read</span>();a[i].p.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,x;j&lt;=a[i].k;j++)x=<span class="built_in">read</span>(),a[i].p.<span class="built_in">push_back</span>(x),a[i].id=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			lst=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a[i].k;j++)</span><br><span class="line">			&#123;mp[a[i].p[j]].<span class="built_in">push_back</span>(a[i].id);</span><br><span class="line">				<span class="keyword">if</span>(lst&gt;=<span class="number">0</span>&amp;&amp;col[a[i].p[j]]!=lst)</span><br><span class="line">				&#123;</span><br><span class="line">					ans1=a[i].id;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;mp[a[i].p[j]].<span class="built_in">size</span>();x++)f1[mp[a[i].p[j]][x]]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;mp[a[i].p[j<span class="number">-1</span>]].<span class="built_in">size</span>();x++)f2[mp[a[i].p[j<span class="number">-1</span>]][x]]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)<span class="keyword">if</span>(f1[x]^f2[x])</span><br><span class="line">					&#123;</span><br><span class="line">						ans2=x;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">memset</span>(f1,<span class="number">0</span>,<span class="built_in">sizeof</span>(f1));</span><br><span class="line">					<span class="built_in">memset</span>(f2,<span class="number">0</span>,<span class="built_in">sizeof</span>(f2));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				lst=col[a[i].p[j]];</span><br><span class="line">				col[a[i].p[j]]=i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans1)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans1)<span class="built_in">printf</span>(<span class="string">&quot;YES\n%d %d\n&quot;</span>,ans1,ans2);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>网站最后几分钟崩了没交上，后来延时差点以为自己提交忘删调试信息。不过还好 AC 了。</p>
<hr>
<p><del>都多久了才来写</del></p>
<p>T3 看了一眼，感觉不会，也没时间了，就没做。</p>
<p>最终分数：200。</p>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>比赛游记</tag>
      </tags>
  </entry>
  <entry>
    <title>POI2014 HOT-Hotels 加强版</title>
    <url>/2022/04/09/POI2014-HOT-Hotels-%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P5904">P5904 POI2014 HOT-Hotels 加强版</a></p>
<p>注意代码中数据范围加大到 $10^6$</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个乱搞算法，如果您发现错误请及时指出。</p>
<p>首先，可以发现三元组一定是有一个中心点，到三个点的距离相等，而且到这些点的路径只在该点重合。似乎有些抽象，放张图吧：</p>
<p><img src="/2022/04/09/POI2014-HOT-Hotels-%E5%8A%A0%E5%BC%BA%E7%89%88/1.png"></p>
<p>那么我们对于每一个节点，求一下它的子树中到它距离为 $d$ 的点。原问题中向下的那些情况就很好求了。</p>
<blockquote>
<p>长链剖分，好的，这题做完了！</p>
<p>诶不对啊你还没求那个向上的情况呢！</p>
<p>向上的情况？从上往下再 DP 一次不就完了？</p>
<p>不对啊你求完上面的长链上的 DP 值已经没了啊！</p>
</blockquote>
<p>节点的 DP 值直接从重儿子继承，相当于重儿子的 DP 值已经被覆盖了。</p>
<p>怎么办？</p>
<p>让我们忽视一些细节：我们真的需要<strong>和长链的 DP 数组大小相同那么多的 DP 值吗</strong>？（说得不太明白，领会精神吧）</p>
<p>更新答案至少要两个儿子的子树，所以即使重儿子一枝独秀也没有用。所以我们只需要保留次长儿子的深度那么多的 DP 值。也就是说只有一部分 DP 值对于求解是必要的。</p>
<p>现在如果我们保存所有必要的 DP 值，需要多大的空间呢？可以发现是 $O(n)$ 的。</p>
<p>接下来在树上从上到下 DP：$g[x][i]$ 表示到 $x$ 距离为 $i$ 且到 $x$ 路径经过 $x$ 的父亲的点的个数。相当于倒序的长链剖分 DP，复杂度应该是 $O(n)$ 的。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>挺丑的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,fa[mxn],son[mxn],dep[mxn],son2[mxn],dep2[mxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[mxn&lt;&lt;<span class="number">1</span>];<span class="type">int</span> t[mxn],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].to=v,e[cnt].nxt=t[u],t[u]=cnt;</span><br><span class="line">	e[++cnt].to=u,e[cnt].nxt=t[v],t[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[x]=f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=t[x];i;i=e[i].nxt)<span class="keyword">if</span>(e[i].to!=f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(e[i].to,x);</span><br><span class="line">		<span class="keyword">if</span>(dep[e[i].to]&gt;dep[son[x]])son2[x]=son[x],son[x]=e[i].to;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dep[e[i].to]&gt;dep[son2[x]])son2[x]=e[i].to;</span><br><span class="line">	&#125;</span><br><span class="line">	dep[x]=dep[son[x]]+<span class="number">1</span>,dep2[x]=dep[son2[x]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll _2(ll _1_,ll _2_)</span><br><span class="line">&#123;</span><br><span class="line">	ll ret=_1_*_1_-_2_;</span><br><span class="line">	<span class="keyword">return</span> ret/<span class="number">2LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll _3(ll _1_,ll _2_,ll _3_)</span><br><span class="line">&#123;</span><br><span class="line">	ll ret=_1_*_1_*_1_+<span class="number">2LL</span>*_3_<span class="number">-3LL</span>*_1_*_2_;</span><br><span class="line">	<span class="keyword">return</span> ret/<span class="number">6LL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll buf[mxn];ll *now=buf,*f[mxn];</span><br><span class="line">ll buf2[mxn],b1[mxn],b2[mxn],ans;</span><br><span class="line">ll buf3[mxn],*won=buf3,*ff[mxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[x]=++now;</span><br><span class="line">	f[x][<span class="number">0</span>]=<span class="number">1LL</span>;</span><br><span class="line">	<span class="keyword">if</span>(son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dp1</span>(son[x]);</span><br><span class="line">		ff[son[x]]=++won;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dep2[x]<span class="number">-1</span>;i++)ff[son[x]][i]=f[son[x]][i],++won;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=t[x];i;i=e[i].nxt)<span class="keyword">if</span>(!f[e[i].to])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dp1</span>(e[i].to);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dep[e[i].to];j++)f[x][j+<span class="number">1</span>]+=f[e[i].to][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(son2[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dep2[x]<span class="number">-1</span>;i++)b1[i]+=ff[son[x]][i]*ff[son[x]][i],b2[i]+=ff[son[x]][i]*ff[son[x]][i]*ff[son[x]][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t[x];i;i=e[i].nxt)<span class="keyword">if</span>(e[i].to!=fa[x]&amp;&amp;e[i].to!=son[x])<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dep[e[i].to];j++)b1[j]+=f[e[i].to][j]*f[e[i].to][j],b2[j]+=f[e[i].to][j]*f[e[i].to][j]*f[e[i].to][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dep2[x]<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=_3(f[x][i+<span class="number">1</span>],b1[i],b2[i]);</span><br><span class="line">			(*(f[son2[x]]-buf+buf2+i))=_2(f[x][i+<span class="number">1</span>],b1[i]);</span><br><span class="line">			b1[i]=b2[i]=<span class="number">0LL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(son[x])won=ff[son[x]]<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(son2[x])<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dep2[x];i++)f[son2[x]][i<span class="number">-1</span>]=f[x][i];</span><br><span class="line">&#125;</span><br><span class="line">ll fub[mxn&lt;&lt;<span class="number">1</span>];ll *g[mxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">(<span class="type">int</span> x,<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			now-=((dep[x]&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">			g[x]=now+dep[x];</span><br><span class="line">			<span class="keyword">if</span>(fa[x])<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dep[x];i++)g[x][i]=g[fa[x]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> g[x]=g[fa[x]]<span class="number">-1</span>;</span><br><span class="line">		g[x][<span class="number">0</span>]=<span class="number">1LL</span>;</span><br><span class="line">		<span class="keyword">if</span>(fa[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=dep2[fa[x]]&amp;&amp;i&lt;dep[x];i++)</span><br><span class="line">			g[x][i]+=f[son2[fa[x]]][i<span class="number">-2</span>];</span><br><span class="line">			<span class="keyword">if</span>(dep2[fa[x]]&gt;<span class="number">1</span>)--g[x][<span class="number">2</span>];</span><br><span class="line">			<span class="type">int</span> y=x,h=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=dep2[fa[x]]&amp;&amp;i&lt;dep[x];i++)</span><br><span class="line">			&#123;</span><br><span class="line">					<span class="keyword">while</span>(i<span class="number">-3</span>-h&gt;=dep2[y]<span class="number">-1</span>)y=son[y],++h;</span><br><span class="line">					<span class="keyword">if</span>(i<span class="number">-3</span>-h&lt;<span class="number">0</span>)g[x][i]--;</span><br><span class="line">					<span class="keyword">else</span> g[x][i]-=f[son2[y]][i<span class="number">-3</span>-h];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(fa[x]&amp;&amp;son2[x])<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dep2[x]<span class="number">-1</span>;i++)</span><br><span class="line">		ans+=g[x][i+<span class="number">1</span>]*(*(f[son2[x]]-buf+buf2+i));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=t[x];i;i=e[i].nxt)<span class="keyword">if</span>(e[i].to!=fa[x]&amp;&amp;e[i].to!=son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dp2</span>(e[i].to,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dp2</span>(son[x],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),<span class="built_in">ad</span>(x,y);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dp1</span>(<span class="number">1</span>);</span><br><span class="line">	now=fub+(mxn&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dp2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/record/72657953">提交记录</a></p>
]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM 后缀自动机</title>
    <url>/2022/02/14/SAM-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><p>如果在一个 $DAG$ 上表示一个字符串的所有子串，朴素的想法是将其所有后缀加入 $Trie$ 中，然而这样节点数是 $O(n^2)$ 的。可以发现，图中节点有很多可以合并之处。</p>
<p>首先是后缀本身。如果先不考虑后缀的公共前缀的存在，那么根本没有必要对每一个后缀都重新存储，可以直接用一条链表示原串，再从根指向各个节点，这样就合并了各后缀，因为只要跳过了开头的一段就可以得到一个后缀。这相当于是 $Trie$ 是菊花图时，把那些后缀拉过来，强行与最长的后缀（即原串）合并，保留那些与根相连的边。图中原串为 <code>abc</code>。</p>
<p><img src="/2022/02/14/SAM-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/1.png"></p>
<p>然而后缀可能存在公共的前缀，这使得 Trie 不是菊花图。这样按之前的做法，可能有一个子串出现多次。这不利于解决问题，不是我们想要的。因此 SAM 的一个限定条件是每一个子串都恰好出现一次。</p>
<p>考虑之前做法的本质。由于新加入一个字符 <code>c</code> 时该字符从未出现过，因此增加的子串为所有原有后缀加上 <code>c</code> 和 <code>c</code> 本身，即新的后缀。但如果 <code>c</code> 之前已经出现过，就会出现某些后缀之前出现过，就不能这样加边了。</p>
<p>现在假设我们建好了前 $n$ 个字符的 SAM，现在又加入了一个字符 <code>c</code>。首先一定会与之前的末尾字符连边，这样就有了整个串这个子串。此时新增添的子串一定是原有的能到达的后缀（即，这些后缀是在 SAM 中以到达末尾节点得到的子串，这个后缀除了在后缀的位置上外没有另外出现过）加上了 <code>c</code>，不可能在 SAM 中出现过，否则去掉这个字符一定也出现过。考虑那些之前出现过，但加上 <code>c</code> 后首次出现的后缀。</p>
<p><strong>如果加入之后较大的后缀出现过，较小的后缀就一定也出现过了</strong>。因此从大到小考虑这些后缀（此处为原串后缀）。如果某个后缀对应的节点没有 <code>c</code> 的边就连边，否则就停止这一过程。</p>
<p>那么如何考察这些后缀呢？</p>
<p>由于每个子串至多对应一个节点，因此可以在每一个节点存储一个指向上一个子串节点的指针，其指向的节点所表示的子串为<strong>与当前节点子串由不同节点表示的后缀</strong>中最长的一个，而更短的后缀将递归得到。</p>
<p>现在考虑不同子串由同一个子串表示的问题。如一开始的图，<code>&quot;c&quot;</code>，<code>&quot;bc&quot;</code>，<code>&quot;abc&quot;</code> 都由同一个节点表示。但这其实不是问题，而是我们优化的结果。如果两个子串所有出现位置的右端点相同，那么这两个子串的处理不会有区别。而也只有这样的两个子串才会由同一个节点表示。贯彻落实这样的优化精神，我们称一个串 $s$ 所有出现位置的右端点组成的集合为，$\texttt{endpos}(s)$，$\texttt{endpos}(s)$ 相同的子串由同意节点表示。</p>
<h2 id="texttt-endpos"><a href="#texttt-endpos" class="headerlink" title="$\texttt{endpos}$"></a>$\texttt{endpos}$</h2><p>关于 $\texttt{endpos}$，我们不加证明地给出结论（其实证明很简单）：</p>
<ol>
<li>若 $\texttt{endpos}(s)=\texttt{endpos}(t),\text{len}(s)\le \text{len}(t)$，则 $s$ 是 $t$ 的后缀。</li>
<li>对于 $s,t,\text{len}(s)\le \text{len}(t)$，有 $\texttt{endpos}(s)\in\texttt{endpos}(t)$ 或 $\texttt{endpos}(s)\cap\texttt{endpos}(t)=\emptyset$。</li>
<li>$\texttt{endpos}$ 相同的子串组成一个 $\texttt{endpos}$ 等价类。一个等价类中的子串为一个串的连续的一些后缀。</li>
<li>$\texttt{endpos}$ 等价类的数量为 $O(n)$。</li>
</ol>
<p>通过 $\texttt{endpos}$，我们将建立 $\texttt{Parent Tree}$。</p>
<h2 id="texttt-Parent-Tree"><a href="#texttt-Parent-Tree" class="headerlink" title="$\texttt{Parent Tree}$"></a>$\texttt{Parent Tree}$</h2><p>在一个子串的开头添加字符。一开始可能一直在原等价类内，如果每一个节点表示一个 $\texttt{endpos}$ 等价类，那么此时还一直在同一个节点上。但某一时刻节点发生变化，令新的节点是原节点的儿子。容易发现，这样建立的 $\texttt{Parent Tree}$ 上，儿子节点的 $\texttt{endpos}$ 是其父亲节点的 $\texttt{endpos}$ 的不交子集。</p>
<p>事实上，之前所说“<strong>与当前节点子串由不同节点表示的后缀</strong>中最长的一个”，就是在 $\texttt{Parent Tree}$ 上不断寻找父亲。</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>回到 SAM 的构造。</p>
<p>加入一个字符 <code>c</code>，创建点 $o$，首先连之前结尾 <code>lst</code> 的边。接下来跳父亲直到有 <code>c</code> 的连边。</p>
<p>如果没有父亲有边，那么遍历结束，新节点父亲为 <code>1</code>。</p>
<p>如果遇到一个祖先有边，会发现一个问题。</p>
<p>有可能原本 $\texttt{endpos}$ 相同的子串，在加入<code>c</code> 后 $\texttt{endpos}$ 不同了。比如 <code>abc</code>，加入 <code>c</code>，<code>c</code> 的 $\texttt{endpos}$ 不同了。</p>
<p>先考虑这种情况没有发生：我们只需要令 $\text{fa}(o)$ 等于这个祖先节点的 <code>c</code> 边所通向的节点即可。</p>
<p>下面考虑这种情况发生。</p>
<p>如何判断这种情况的发生？为了方便，记所寻到的祖先节点为 $x$，$x$ 的 <code>c</code> 边通向 $y$。</p>
<p>如果在这种情况发生，一定是 $y$ 所表示的一些子串是加入之后的后缀（称“合法”），<strong>一些子串不是（非法）</strong>。这些合法子串的长度都与 $x$ 以及其通向 $y$ 的祖先所表示的子串得长度 $+1$ 一一对应，而非法的子串就一定没有一个这样的子串与之对应。由 $\texttt{endpos}$ 的性质可知非法子串一定是最长的一些子串。因此我们只要知道是否（$\text{ml}(x)$ 表示 $x$ 的等价类中最长子串的长度） $\text{ml}(x)+1=\text{ml}(y)$ 即可。因此在每个节点维护 $\text{ml}$。</p>
<p>现在加入之后，$y$ 点有两个等价类。因此新建一个节点 $t$，把那些 $\texttt{endpos}$ 增加了的拿出来（这些是那些合法子串，他们作为新串后缀出现了一次）。</p>
<p>容易知道，$\text{ml}(t)=\text{ml}(x)+1,\text{fa}(t)=\text{fa}(y),\text{fa}(y)=t,\text{fa}(o)=t$。</p>
<p>考虑边。首先考虑出边，虽然 $t$ 和 $y$ 的 $\texttt{endpos}$ 不同，但因为这两个节点的子串的 $\texttt{endpos}$ 差异只在原串的结尾处而这里不可能再向后拓展一个字符，在结尾加一个字符后肯定在一个等价类中，因此 $t$ 的出边只需继承 $y$ 即可。接下来考虑入边。发现 $x$ 的串为 $\texttt{endpos}$ 原非空而增加的最大的串，此时应该更改 $x$ 的串的后缀，因此跳 $x$ 的父亲。对于边 <code>c</code> 指向 $y$ 的点，改为让它指向 $t$。</p>
<p>如果遇到了一个节点的边 <code>c</code> 不指向 $y$，那么它一定指向 $y$ 的祖先，而 $\text{fa}(y)=t$，因此之后再也不会出现这种情况了。（相当于出了 $t$ 的等价类就不用管了，因为更短的后缀，它的儿子节点已经处理过了，那么它也就跟着把 $\texttt{endpos}$ 更新了，因此只需把原来 $y$ 里的移到 $t$ 里去就行了）</p>
<h2 id="模版题-amp-代码实现"><a href="#模版题-amp-代码实现" class="headerlink" title="模版题 &amp; 代码实现"></a>模版题 &amp; 代码实现</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P3804">P3804 【模板】后缀自动机 (SAM)</a></p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>即求 $\max_{x}(\text{sizeof}(\texttt{endpos}(x))\text{ml}(x))$。</p>
<p>在 $\texttt{Parent Tree}$ 上 DFS，显然有 $\texttt{endpos}$ 等于所有儿子 $\texttt{endpos}$ 和本身如果是前缀前缀的结束位置之并。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ch[<span class="number">26</span>],fa,ml;<span class="type">bool</span> fl;</span><br><span class="line">&#125;sam[<span class="number">2000000</span>];<span class="type">int</span> tot,lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buil</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=lst;lst=++tot;sam[lst].fl=<span class="number">1</span>;sam[lst].ml=sam[x].ml+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((x)&amp;&amp;(!sam[x].ch[c]))sam[x].ch[c]=lst,x=sam[x].fa;</span><br><span class="line">	<span class="keyword">if</span>(!x)<span class="comment">//case 1</span></span><br><span class="line">	&#123;</span><br><span class="line">		sam[lst].fa=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> y=sam[x].ch[c];</span><br><span class="line">	<span class="keyword">if</span>(sam[x].ml+<span class="number">1</span>==sam[y].ml)<span class="comment">//case 2</span></span><br><span class="line">	&#123;</span><br><span class="line">		sam[lst].fa=y;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++tot;<span class="comment">//case 3</span></span><br><span class="line">	sam[tot]=sam[y],sam[tot].fl=<span class="number">0</span>;sam[tot].ml=sam[x].ml+<span class="number">1</span>;sam[y].fa=sam[lst].fa=tot;</span><br><span class="line">	<span class="keyword">while</span>((x)&amp;&amp;(sam[x].ch[c]==y))sam[x].ch[c]=tot,x=sam[x].fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="type">int</span> nxt[<span class="number">3000000</span>],to[<span class="number">3000000</span>],cnt,h[<span class="number">2000000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	to[++cnt]=v;</span><br><span class="line">	nxt[cnt]=h[u];</span><br><span class="line">	h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=(sam[x].fl);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=nxt[i])</span><br><span class="line">	ret+=<span class="built_in">dfs</span>(to[i]);</span><br><span class="line">	<span class="keyword">if</span>(ret&gt;<span class="number">1</span>)ans=<span class="built_in">max</span>(ans,<span class="number">1LL</span>*ret*sam[x].ml);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> c;tot=lst=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)<span class="built_in">buil</span>(c-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)<span class="built_in">ad</span>(sam[i].fa,i);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>由 $\texttt{endpos}$ 的数量可知为 $O(n)$。</p>
<h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>首先建一个生成树，边数 $O(n)$。</p>
<p>如果在自动机上跑遍所有子串必然遍历到所有边，但我们不需要这样做。考虑到所有的子串都一定是某个后缀的前缀，因此只需跑所有的后缀。</p>
<p>我们从 <code>lst</code> 出发，逆向跑回 1 节点。</p>
<p>而在跑每一个后缀的时候，如果发现走不通，就加一条应该走的边。注意到此时这条边所通向节点一定可以通向 1 节点（有树做基础），并且这样走由于经过了刚才新添加的边，因此一定产生新的后缀。由此可以发现，每加一条边，至少可以多一个后缀。因此边也是 $O(n)$ 的。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>注意到其中两个 <code>while</code> 是时间复杂度不确定的原因。</p>
<p>对于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((x)&amp;&amp;(!sam[x].ch[c]))sam[x].ch[c]=lst,x=sam[x].fa;</span><br></pre></td></tr></table></figure>

<p>事实上是加边，因此是 $O(n)$ 的。</p>
<p>而：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((x)&amp;&amp;(sam[x].ch[c]==y))sam[x].ch[c]=tot,x=sam[x].fa;<span class="comment">//case 3</span></span><br></pre></td></tr></table></figure>

<p>我们知道这句是将 $\texttt{endpos}(y)$ 中的串移到 $\texttt{endpos}(t)$ 中。</p>
<p>如果这次 <code>case 3</code> 和上一次已经相互独立（指新建节点中的后缀的左端点的范围不交），那么转移的串数一定不多于这一段范围大小，因此 $O(n)$。</p>
<p>否则，考虑上一次 <code>case 3</code>，考虑这两次修改的子串的共同范围：</p>
<p><img src="/2022/02/14/SAM-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/2.png"></p>
<p>可以发现，重复范围内开头的后缀属于同一个 $\texttt{endpos}$（当时新建节点的 $\texttt{endpos}$ 通过特定路径到达的节点，因为此间未发生一个  $\texttt{endpos}$ 分裂），因此平均还是 $O(n)$ 的。</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://www.sciencedirect.com/science/article/pii/0304397585901574">The smallest automation recognizing the subwords of a text - ScienceDirect</a></p>
<p><a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie">史上最通俗的后缀自动机详解 - KesdiaelKen 的博客</a></p>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>做题记录-省选2021A</title>
    <url>/2022/04/14/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-%E7%9C%81%E9%80%892021A/</url>
    <content><![CDATA[<h2 id="P7514-卡牌游戏"><a href="#P7514-卡牌游戏" class="headerlink" title="P7514 卡牌游戏"></a><a href="https://www.luogu.com.cn/problem/P7514">P7514 卡牌游戏</a></h2><p>首先，翻面的一定是左边连续一段和右边连续一段。</p>
<p>那么假设我都翻的右面，现在把翻的机会一个个移向左边。提前处理掉一定不会翻的卡牌，可以发现有两个区间：$[\min b_r,a_r]$ 和 $[a_l,\max b_l]$。前者用 <code>()</code>，后者用 <code>[]</code> 表示，<code>&#123;&#125;</code> 为下一个 <code>[]</code>，<code>&lt;&gt;</code> 是上一个。两个区间只会向左移。</p>
<p>答案一定是下述情况：可翻卡牌数饱和；<code>)]&#125;</code>；<code>[(&#123;)]&#125;</code>；<code>&lt;([)&gt;]</code>；<code>[()]</code> 的最小值。除最后一种情况都可直接指针扫。而最后一种情况每次事实上是维护一段最值，每次从最前删除，最后加入，可维护一单调队列。</p>
<p>非常笨拙然而是 $O(n)$ 的。</p>
<h2 id="P7515-矩阵游戏"><a href="#P7515-矩阵游戏" class="headerlink" title="P7515 矩阵游戏"></a><a href="https://www.luogu.com.cn/problem/P7515">P7515 矩阵游戏</a></h2><p>显然有 $n+m-1$ 个自由元，那就设在第一行和第一列。显然每一组自由元的取值唯一对应了一个矩阵。</p>
<p>考虑两个矩阵，他们仅有一个自由元不同。为了保证其它自由元不变，矩阵的变化一定是：在该行或列的元素应依次 $+c,-c,+c,\cdots$。</p>
<p>有一个例外：$a_{1,1}$。如果改变他，则所有的非自由元都会改变。为了统一我们修改第一行和第一列的所有元素。如果再对其他自由元修改使其回复原值，那么所造成的修改就是它应有的修改。</p>
<p>那么钦定这些自由元是 0，求出矩阵原始值。然后进行一些操作：对某一行或某一列（特殊地，第一行和第一列由同一变量控制）进行上述操作。</p>
<p>调整一下符号，可以化为 $nm$ 个不等式，对于 $a_{i,j}$，<br>$$<br>l_{i,j}\le x_i-y_j\le r_{i,j}<br>$$<br>即可差分约束。</p>
<h2 id="P7516-图函数"><a href="#P7516-图函数" class="headerlink" title="P7516 图函数"></a><a href="https://www.luogu.com.cn/problem/P7516">P7516 图函数</a></h2><h3 id="一个转化"><a href="#一个转化" class="headerlink" title="一个转化"></a>一个转化</h3><p>将题目中 $f(u,G)$ 能够是 cnt+1 的情况称为 $u\rightarrow v$ 。</p>
<p>一定存在 $u,v$ 之间路径，其上所有的点 $w$，有 $u\nrightarrow w$ 或 $w&gt;v$。</p>
<p>如果不存在路径使得 $w&gt;v$，那么一定存在路径上的点，$u\nrightarrow w$，$w&lt;v$。</p>
<p>那么路径上其他点一定满足 $u\nrightarrow t$ 或 $t&gt;v&gt;w$。</p>
<p>进而存在符合要求的 $u,w$ 双向路径。矛盾。</p>
<p>故 $u\rightarrow v$ 等价于存在 $u,v$ 之间路径，其上的点都满足 $w&gt;v$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以从大到小向图中加入节点，在新加入节点 $u$ 时统计 $v\rightarrow u$ 的答案。</p>
<p>求 $u,v$ 间路径上<strong>边的编号的最小值</strong>的最大值，由于我们从小到大删边，就可以查分了。</p>
<p>于是你就可以 $O(n^3)$Floyd 了。（能过就离谱，某卡常大师跑的比 $O(nm)$ 快更离谱）</p>
<p>然而这不同于一般的最短路。我们发现：可以从大到小枚举边：如果某一时刻加入这条边后某个节点忽然连通那么它的答案就是新加入边的编号而且以后不会变了。这样就不会反复更新一个点，如 Floyd 那样浪费时间。</p>
<p>拿边更新的时候，如果入点已求过就正常了。如果没求过呢？</p>
<p>那么我保留所有现在更新不了但以后可能更新的边。当新更新一个点时在这些边上进行 BFS，显然一个节点只会更新一次。容易分析此时复杂度为 $O(n(n+m))$。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fr,to,nxt;<span class="type">bool</span> dir;</span><br><span class="line">&#125;e[<span class="number">200005</span>];<span class="type">int</span> t[<span class="number">1005</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="number">0</span>;<span class="type">int</span> mu=<span class="built_in">min</span>(u,v);</span><br><span class="line">	<span class="keyword">if</span>(u&gt;v)flag=<span class="number">1</span>;</span><br><span class="line">	e[++cnt].to=v,e[cnt].nxt=t[mu],t[mu]=cnt,e[cnt].dir=flag,e[cnt].fr=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nxt,to;</span><br><span class="line">&#125;E[<span class="number">200005</span>];<span class="type">int</span> T[<span class="number">1005</span>],CNT;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AD</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	E[++CNT].to=v,E[CNT].nxt=T[u],T[u]=CNT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q[<span class="number">1005</span>],l,r;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> *tima)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	l=r=<span class="number">1</span>,q[<span class="number">1</span>]=x;</span><br><span class="line">	<span class="type">int</span> _;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		_=q[l++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=T[_];i;i=E[i].nxt)<span class="keyword">if</span>(!tima[E[i].to])tima[E[i].to]=tima[x],q[++r]=E[i].to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tim[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1005</span>],timb[<span class="number">1005</span>],timc[<span class="number">1005</span>];</span><br><span class="line"><span class="type">bool</span> fl[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		<span class="built_in">ad</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(timb,<span class="number">0</span>,<span class="built_in">sizeof</span>(timb));<span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="built_in">sizeof</span>(T));CNT=<span class="number">0</span>;timb[i]=inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=t[i];j;j=e[j].nxt)<span class="keyword">if</span>(!e[j].dir)fl[j]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m,x,y;j;j--)<span class="keyword">if</span>(fl[j])</span><br><span class="line">		&#123;</span><br><span class="line">			x=e[j].fr,y=e[j].to;<span class="keyword">if</span>(timb[y])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(timb[x])timb[y]=j,<span class="built_in">bfs</span>(y,timb);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">AD</span>(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=t[i];j;j=e[j].nxt)fl[j]=e[j].dir;</span><br><span class="line">		<span class="built_in">memset</span>(timc,<span class="number">0</span>,<span class="built_in">sizeof</span>(timc));<span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="built_in">sizeof</span>(T));CNT=<span class="number">0</span>;timc[i]=inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m,x,y;j;j--)<span class="keyword">if</span>(fl[j])</span><br><span class="line">		&#123;</span><br><span class="line">			x=e[j].to,y=e[j].fr;<span class="keyword">if</span>(timc[y])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(timc[x])timc[y]=j,<span class="built_in">bfs</span>(y,timc);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">AD</span>(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=t[i];j;j=e[j].nxt)<span class="keyword">if</span>(!e[j].dir)fl[j]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)<span class="keyword">if</span>(timb[j]&amp;&amp;timc[j])tim[<span class="built_in">min</span>(timb[j],timc[j])]++;</span><br><span class="line">	&#125;</span><br><span class="line">	tim[m+<span class="number">1</span>]=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)tim[i]=tim[i]+tim[i+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tim[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P7518-宝石"><a href="#P7518-宝石" class="headerlink" title="P7518 宝石"></a><a href="https://www.luogu.com.cn/problem/P7518">P7518 宝石</a></h2><p>如果我给颜色按收集顺序重新编号，那么我就是在求最长的序列 1,2,…</p>
<p>如果在链上，可以想到用 $f[i]$ 表示下一个颜色为 $col[i]+1$ 的位置。那么我可以倍增求出从该位置向后拓展 $x$ 位的最短长度，倍增求出区间中第一个 1，即可倍增求解。</p>
<p>现在在树上。路径分两段：上去的和下来的。对于上去的可以直接树上倍增。对于下来的向下走不太方便可以二分答案反向倍增，现在问题转化为 $x$ 的祖先中深度最深的颜色为 $c$ 的节点。可以用主席树。</p>
<p>时间复杂度 $O(n\log^2n)$。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[<span class="number">400005</span>];<span class="type">int</span> t[<span class="number">200005</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].to=v,e[cnt].nxt=t[u],t[u]=cnt;</span><br><span class="line">	e[++cnt].to=u,e[cnt].nxt=t[v],t[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cmap[<span class="number">50005</span>],col[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,val;</span><br><span class="line">&#125;tr[<span class="number">8000000</span>];<span class="type">int</span> siz,rt[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[x].val=<span class="built_in">max</span>(tr[tr[x].ls].val,tr[tr[x].rs].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> v,<span class="type">int</span> key,<span class="type">int</span> val,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u=++siz;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		tr[u].val=val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="keyword">if</span>(v)tr[u]=tr[v];</span><br><span class="line">	<span class="keyword">if</span>(key&lt;=mid)<span class="built_in">insert</span>(tr[u].ls,tr[v].ls,key,val,l,mid);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(tr[u].rs,tr[v].rs,key,val,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">upd</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> key,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[u].val;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(key&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(tr[u].ls,key,l,mid);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(tr[u].rs,key,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[<span class="number">200005</span>],up[<span class="number">200005</span>][<span class="number">20</span>],down[<span class="number">200005</span>][<span class="number">20</span>],fa[<span class="number">200005</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[x]=dep[fath]+<span class="number">1</span>,fa[x][<span class="number">0</span>]=fath;</span><br><span class="line">	<span class="built_in">insert</span>(rt[x],rt[fath],col[x],x,<span class="number">1</span>,c);</span><br><span class="line">	<span class="keyword">if</span>(col[x]&gt;<span class="number">1</span>)down[x][<span class="number">0</span>]=<span class="built_in">query</span>(rt[x],col[x]<span class="number">-1</span>,<span class="number">1</span>,c);<span class="keyword">if</span>(col[x]&lt;c)up[x][<span class="number">0</span>]=<span class="built_in">query</span>(rt[x],col[x]+<span class="number">1</span>,<span class="number">1</span>,c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;up[x][i<span class="number">-1</span>];i++)up[x][i]=up[up[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;down[x][i<span class="number">-1</span>];i++)down[x][i]=down[down[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;fa[x][i<span class="number">-1</span>];i++)fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=t[x];i;i=e[i].nxt)<span class="keyword">if</span>(e[i].to!=fath)<span class="built_in">dfs</span>(e[i].to,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>&amp;&amp;dep[u]&gt;dep[v];i--)<span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])u=fa[u][i];</span><br><span class="line">	<span class="keyword">if</span>(u!=v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];</span><br><span class="line">		u=fa[u][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> stpos,<span class="type">int</span> edpos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>&amp;&amp;dep[stpos]&gt;dep[edpos];i--)<span class="keyword">if</span>(dep[down[stpos][i]]&gt;=dep[edpos])stpos=down[stpos][i];</span><br><span class="line">	<span class="keyword">return</span> stpos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> cl,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> stpos,<span class="type">int</span> edpos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid,d,fm;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		fm=<span class="built_in">query</span>(rt[stpos],mid,<span class="number">1</span>,c),d=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(dep[fm]&gt;=dep[edpos])d=<span class="built_in">Down</span>(fm,edpos);</span><br><span class="line">		<span class="keyword">if</span>(d&amp;&amp;col[d]&lt;=cl)l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,p;i&lt;=c;i++)<span class="built_in">read</span>(p),cmap[p]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,w;i&lt;=n;i++)<span class="built_in">read</span>(w),col[i]=cmap[w];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)<span class="built_in">read</span>(u),<span class="built_in">read</span>(v),<span class="built_in">ad</span>(u,v);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> q;<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> s,f1,T,lc,cl,a;q;q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(s),<span class="built_in">read</span>(T),</span><br><span class="line">		lc=<span class="built_in">lca</span>(s,T);</span><br><span class="line">		f1=<span class="built_in">query</span>(rt[s],<span class="number">1</span>,<span class="number">1</span>,c);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>&amp;&amp;dep[f1]&gt;dep[lc];i--)<span class="keyword">if</span>(dep[up[f1][i]]&gt;=dep[lc])f1=up[f1][i];</span><br><span class="line">		<span class="keyword">if</span>(col[f1]==c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cl=(dep[f1]&gt;=dep[lc])?(col[f1]+<span class="number">1</span>):<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(T==lc)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cl<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a=<span class="built_in">binary</span>(cl,cl,c,T,lc);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P7519-滚榜"><a href="#P7519-滚榜" class="headerlink" title="P7519 滚榜"></a><a href="https://www.luogu.com.cn/problem/P7519">P7519 滚榜</a></h2><p>如果我们知道了最终排名，那么很容易贪心求出最少的过题数。</p>
<p>那么如果我们确定了排名的后 $x$ 位，现在还剩 $y$ 道题可以切，上一位是 $z$，封完榜又切了 $k$ 道题，枚举这一位是谁，他至少要切多少题，才能保有他的位置。那么这就是 $O(2^nm^2n)$ 的。</p>
<p>考虑优化：我们在求完这一位至少切这么多题之后，由于封榜后切的题数不降，因此我们先让剩下的人都切这些题，判断大小的时候相当于谁都一道题没切。我们在可供切的题数中减去这部分即可，这样减去一维（这好像叫费用提前计算？反正叫什么无所谓），空间 $O(2^nmn)$，时间 $O(2^nmn^2)$。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">14</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">8193</span>][<span class="number">501</span>][<span class="number">13</span>],g[<span class="number">8193</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> s,<span class="type">int</span> left,<span class="type">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(f[s][left][lst]&gt;=<span class="number">0</span>)<span class="keyword">return</span> f[s][left][lst];</span><br><span class="line">	f[s][left][lst]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ss=s,y,nb;</span><br><span class="line">	<span class="keyword">while</span>(ss)y=<span class="built_in">lowbit</span>(ss),</span><br><span class="line">	nb=<span class="built_in">max</span>(<span class="number">0</span>,a[lst]-a[g[y]]+(g[y]&gt;lst)),</span><br><span class="line">	f[s][left][lst]+=<span class="built_in">dfs</span>(x+<span class="number">1</span>,s^y,left-nb*(n-x),g[y]),</span><br><span class="line">	ss^=y;</span><br><span class="line">	<span class="keyword">return</span> f[s][left][lst];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="type">int</span> ma=<span class="number">0</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;n;i++,j&lt;&lt;=<span class="number">1</span>)g[j]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;a[ma])ma=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> o=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>,nb;i&lt;n;i++,j&lt;&lt;=<span class="number">1</span>)nb=a[ma]-a[i]+(i&gt;ma),ans+=<span class="number">1LL</span>*<span class="built_in">dfs</span>(<span class="number">1</span>,j^o,m-nb*n,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P7520-支配"><a href="#P7520-支配" class="headerlink" title="P7520 支配"></a><a href="https://www.luogu.com.cn/problem/P7520">P7520 支配</a></h2><p>可以发现在一个节点 $u$ 的支配集中两个节点一定有支配关系。又因为支配关系有传递性和反对称性，一定存在唯一的一个节点，使得除了 $u$ 所有支配 $u$ 的节点都支配 $v$。那么我们建一棵树，$v$ 是 $u$ 的父亲。一个节点的支配集即该节点的所有祖先。可以 $n^2$ 暴力建树。</p>
<p>现加入一条边 $s\to t$，如果一个节点的支配集变化它的子树中所有节点的支配集一定都变化。那么找到支配集变化的最高的节点；它的父亲支配集不变，那么一定是父亲不再支配他了。</p>
<p>此时一定有 $1\to s\to t\to x$ 不经过 $\text{fa}(x)$。那么 $s$ 不在 $\text{fa}(x)$ 子树中，且 $t\to x$ 不经过 $\text{fa}(x)$。可以预处理；然而从某节点出发到达另一节点不经过到达节点的父亲限制不统一，那么可以建反图，变成一个节点不经过其父亲能到达哪些节点。</p>
<p>时间 $O(n^2+nq)$。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>暴力到连 lca 都是暴力求的，反正数据范围小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nxt,to;</span><br><span class="line">&#125;e[<span class="number">6010</span>],d[<span class="number">6010</span>];<span class="type">int</span> t[<span class="number">3005</span>],tt[<span class="number">3005</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].to=v,e[cnt].nxt=t[u],t[u]=cnt;</span><br><span class="line">	d[cnt].to=u,d[cnt].nxt=tt[v],tt[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; dom[<span class="number">3005</span>];<span class="type">int</span> siz[<span class="number">3005</span>];</span><br><span class="line"><span class="type">int</span> q[<span class="number">3005</span>],l,r;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	q[<span class="number">1</span>]=<span class="number">1</span>,l=r=<span class="number">1</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> _;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		_=q[l++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t[_];i;i=e[i].nxt)<span class="keyword">if</span>(e[i].to!=x&amp;&amp;(!vis[e[i].to]))q[++r]=e[i].to,vis[e[i].to]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="keyword">if</span>(!vis[i])dom[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">3005</span>];vector &lt;<span class="type">int</span>&gt; son[<span class="number">3005</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">3005</span>],dep[<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:son[x])dep[i]=dep[x]+<span class="number">1</span>,<span class="built_in">dfs</span>(i),s[x]+=s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> con[<span class="number">3001</span>][<span class="number">3001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vlos</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	q[<span class="number">1</span>]=x,l=r=<span class="number">1</span>,vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> _;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		_=q[l++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=tt[_];i;i=d[i].nxt)<span class="keyword">if</span>(d[i].to!=fa[x]&amp;&amp;(!vis[d[i].to]))q[++r]=d[i].to,vis[d[i].to]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="keyword">if</span>(!vis[i])con[i][x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((!con[y][x])&amp;&amp;fa[x]!=z)<span class="keyword">return</span> s[x];</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:son[x])</span><br><span class="line">	ret+=<span class="built_in">dfs2</span>(i,y,z);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(Q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">ad</span>(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">solv</span>(i);dom[i].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)siz[i]=dom[i].<span class="built_in">size</span>();siz[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j:dom[i])<span class="keyword">if</span>(siz[j]==siz[i]<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			fa[i]=j,son[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">vlos</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> S,T,x,y,ans;Q;Q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(S),<span class="built_in">read</span>(T);</span><br><span class="line">		x=S,y=T;</span><br><span class="line">		<span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">while</span>(dep[x]&lt;dep[y])y=fa[y];</span><br><span class="line">		<span class="keyword">while</span>(x!=y)x=fa[x],y=fa[y];</span><br><span class="line">		<span class="keyword">if</span>(dep[T]&lt;=dep[x]+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:son[x])</span><br><span class="line">		ans+=<span class="built_in">dfs2</span>(i,T,x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2022/05/04/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 n 的序列 ，排序的轮数 k，执行如下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i from 1 to k</span><br><span class="line">  for j from 1 to n – 1</span><br><span class="line">    if A[j] &gt; A[j+1]</span><br><span class="line">      swap(A[j], A[j+1])</span><br></pre></td></tr></table></figure>

<p>输出排序之后的序列。</p>
<p>$n,k\le 2\times 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>可以离散化一下。</p>
<p>可以发现每次排序后如果一个数之前的所有数都比他小，那么他会向后移动到下一个比他大的数。否则他会向前移动一位，并且他前面比他大的数会少一个。</p>
<p>因此用树状数组统计每个数前面有多少比他大的数。如果 $\ge k$，那么他只会前移 $k$ 位；否则，在他的前面没有比他大的数之后，他会移动到此时第一个比他大的数的前一位。容易知道，最后他会移动到原来 $k-1$ 轮以后最靠前的比他大的数前一位。那么可以从大到小考虑，在他开始后退以后他就成为最靠前的比以后的数大的数。</p>
<p>可以用平衡树来维护 x 轮后最靠前的那个已经考虑了的数，即大于后面的数的数。</p>
<p>$O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seq</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,id;</span><br><span class="line">&#125;s[<span class="number">200010</span>];<span class="type">int</span> mp[<span class="number">200010</span>],a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (seq x,seq y)&#123;<span class="keyword">return</span> x.val&lt;y.val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fw[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> *tr[<span class="number">200010</span>],buf[<span class="number">200010</span>],*now;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tarr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t[<span class="number">200010</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;=n)++t[pos],pos+=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos)ret+=t[pos],pos-=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> treap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ls,rs,pri,siz,tg,v;</span><br><span class="line">    &#125;t[<span class="number">200010</span>];<span class="type">int</span> rt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;t[u].siz=t[t[u].ls].siz+t[t[u].rs].siz+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newt</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t[id].ls=t[id].rs=t[id].tg=<span class="number">0</span>;</span><br><span class="line">        t[id].pri=<span class="built_in">rand</span>(),t[id].siz=<span class="number">1</span>,t[id].v=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[u].ls)t[t[u].ls].tg+=t[u].tg,t[t[u].ls].v+=t[u].tg;</span><br><span class="line">        <span class="keyword">if</span>(t[u].rs)t[t[u].rs].tg+=t[u].tg,t[t[u].rs].v+=t[u].tg;</span><br><span class="line">        t[u].tg=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> siz,<span class="type">int</span> o,<span class="type">int</span> &amp;u,<span class="type">int</span> &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!o)</span><br><span class="line">        &#123;</span><br><span class="line">            u=v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!siz)</span><br><span class="line">        &#123;</span><br><span class="line">            u=<span class="number">0</span>,v=o;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(siz==t[o].siz)</span><br><span class="line">        &#123;</span><br><span class="line">            u=o,v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">d</span>(o);</span><br><span class="line">        <span class="keyword">if</span>(t[t[o].ls].siz&gt;=siz)v=o,<span class="built_in">split</span>(siz,t[o].ls,u,t[v].ls);</span><br><span class="line">        <span class="keyword">else</span> u=o,<span class="built_in">split</span>(siz-t[t[o].ls].siz<span class="number">-1</span>,t[o].rs,t[u].rs,v);</span><br><span class="line">        <span class="built_in">upd</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u)<span class="keyword">return</span> v;<span class="keyword">if</span>(!v)<span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">if</span>(t[u].pri&gt;t[v].pri)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">d</span>(u);</span><br><span class="line">            t[u].rs=<span class="built_in">merge</span>(t[u].rs,v);</span><br><span class="line">            <span class="built_in">upd</span>(u);</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">d</span>(v);</span><br><span class="line">        t[v].ls=<span class="built_in">merge</span>(u,t[v].ls);</span><br><span class="line">        <span class="built_in">upd</span>(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="number">20070106</span>);rt=<span class="number">1</span>,<span class="built_in">newt</span>(<span class="number">1</span>,s[n].id);s[n].id=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)<span class="built_in">newt</span>(i,n),rt=<span class="built_in">merge</span>(rt,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> u,v,id,ret;<span class="built_in">split</span>(k<span class="number">-1</span>,rt,rt,id),</span><br><span class="line">        <span class="built_in">split</span>(pos,rt,u,v);ret=t[id].v<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(v)--t[v].tg,--t[v].v;<span class="built_in">newt</span>(id,x);</span><br><span class="line">        v=<span class="built_in">merge</span>(id,v);</span><br><span class="line">        rt=<span class="built_in">merge</span>(u,v);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;fable.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;fable.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(s[i].val),s[i].id=i;<span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i]=s[i].val,s[i].val=i,a[s[i].id]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fw[i]=i-tarr::<span class="built_in">query</span>(a[i]<span class="number">-1</span>)<span class="number">-1</span>,tarr::<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    treap::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fw[s[i].id]&lt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i].id=treap::<span class="built_in">insert</span>(fw[s[i].id],s[i].id-fw[s[i].id]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i].id-=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[s[i].id]=mp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>考虑一个数：考虑所有比他大的数，每一轮中它们的位置变化：从左到右，第一个变到第二个左面一位，第二个变到第三个左面一位……这里我们不关心谁是谁，对于这个数他们的影响没有什么不同。</p>
<p>因此，一个数如果不是永远不会向后退，那么她一定后退到第 $k$ 个比他大的数的前 $k$ 位。</p>
<p>实现方式比较多。此处采用比较简洁的堆。如果已经出现 $k$ 个比他大，就弹出。并且入队出对错开 $k$ 位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;fable.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;fable.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="type">int</span> n,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=k;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),q.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>,x;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),q.<span class="built_in">push</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>()),q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>()),q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>wqs 二分</title>
    <url>/2022/05/01/wqs-%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>一些关于 wqs 的例题和拓展。如果题目有贪心等做法也会给出。</p>
<h2 id="P2619-国家集训队Tree-I"><a href="#P2619-国家集训队Tree-I" class="headerlink" title="P2619 国家集训队Tree I"></a><a href="https://www.luogu.com.cn/problem/P2619">P2619 国家集训队Tree I</a></h2><p>每次给白边的边权 +c 二分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> s,t,c,_c,col;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> cc)</span></span>&#123;<span class="keyword">if</span>(!col)_c=c+cc;&#125;</span><br><span class="line">&#125;e[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (edge e1,edge e2)&#123;<span class="keyword">return</span> ((e1._c==e2._c)?(e1.col&lt;e2.col):(e1._c&lt;e2._c));&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!fa[u])<span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">return</span> (fa[u]=<span class="built_in">root</span>(fa[u]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;fa[<span class="built_in">root</span>(u)]=<span class="built_in">root</span>(v);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,nd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)e[i].<span class="built_in">ad</span>(x);</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m);</span><br><span class="line">	<span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="built_in">sizeof</span>(fa));</span><br><span class="line">	<span class="type">int</span> l=n<span class="number">-1</span>,i=<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">root</span>(e[i].s)==<span class="built_in">root</span>(e[i].t))i++;</span><br><span class="line">		ret+=e[i].col^<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">merge</span>(e[i].s,e[i].t);++i,--l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid,tmp;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tmp=<span class="built_in">chk</span>(mid);</span><br><span class="line">		<span class="keyword">if</span>(tmp&lt;nd)r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(nd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(e[i].s),<span class="built_in">read</span>(e[i].t),e[i].s++,e[i].t++,<span class="built_in">read</span>(e[i].c),<span class="built_in">read</span>(e[i].col),e[i]._c=e[i].c;</span><br><span class="line">    <span class="type">int</span> cc=<span class="built_in">binary</span>(<span class="number">-100</span>,<span class="number">100</span>,nd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)e[i].<span class="built_in">ad</span>(cc);</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m);</span><br><span class="line">	<span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="built_in">sizeof</span>(fa));</span><br><span class="line">	<span class="type">int</span> l=n<span class="number">-1</span>,i=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">root</span>(e[i].s)==<span class="built_in">root</span>(e[i].t))i++;</span><br><span class="line">		ans+=e[i]._c;</span><br><span class="line">		<span class="built_in">merge</span>(e[i].s,e[i].t);++i,--l;</span><br><span class="line">	&#125;</span><br><span class="line">	ans-=cc*nd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5633-最小度限制生成树"><a href="#P5633-最小度限制生成树" class="headerlink" title="P5633 最小度限制生成树"></a><a href="https://www.luogu.com.cn/problem/P5633">P5633 最小度限制生成树</a></h2><h3 id="法-1：wqs"><a href="#法-1：wqs" class="headerlink" title="法 1：wqs"></a>法 1：wqs</h3><p>每次给与 s 相连的边的边权 +c 二分。判无解：求的的偏移量不在合法范围内。</p>
<h3 id="法-2：贪心"><a href="#法-2：贪心" class="headerlink" title="法 2：贪心"></a>法 2：贪心</h3><p>约定：</p>
<ul>
<li>s 边：与 s 相连的边</li>
<li>i 方案：选择 i 条 s 边的一种生成树方案</li>
<li>i 答案：i 方案中的最优情况</li>
<li>点权：与其相连所有 s 边的最小边权</li>
<li>其他约定以括号形式给出</li>
</ul>
<p>每一个 i 答案都是有 i 条 s 边，断开他们得到 i 棵树的森林。那么<strong>与 s 相连的点一定是所在树中点权最小的点</strong>。</p>
<p>我们想要证明，i 答案一定由 i-1 答案增加一条 s 边得到。</p>
<p>假设我们已得到 i-1 答案，却发现 i 答案不能从 i-1 答案通过增加一条 s 边，即连通一个点与 s 点，并删去原有的一条树边得到。</p>
<p>那么这一定是有一个 i-1 方案此次所连接的 $u$ 点和断开 $v$ 点造成的贡献比较大，而在 i 答案中却不能这样做。</p>
<p>我们一定是选择一个点 $x$，加上它的点权，减去它到他所在的树的树根 $\text{root}(x)$ 的路径 $\text{path}(x)$ 上一条边的边权。这两个符号的下标表示对应于 i 方案 / 答案。</p>
<p>如果 $u$ 与 $v$ 在同一树中，那么在 i 答案中新删去的边在 i-1 答案中一定在 $\text{path}<em>{i-1}(u)$ 或 $\text{path}</em>{i-1}(v)$ 上，那么一定有方法在 i-1 答案上产生更优的解。如果他们在不同树中而满足同样地条件，同理也可以更优。</p>
<p>否则，应断开的那条边 $x$ 一定已经断开，如图：</p>
<p><img src="/2022/05/01/wqs-%E4%BA%8C%E5%88%86/1.png"></p>
<p>可以想到调整断开的顺序：如果调换 $\texttt{split}(\alpha,\text{root}(\alpha),y)$ （通过断开 $y$ 断开两点）和 $\texttt{split}(\beta,\text{root}(\beta),z)$，如果相互独立答案肯定不变。如果 $\text{root}(\beta)=\alpha$，如果断开此边能正常断开答案仍不边；否则变成 $\texttt{split}(\alpha,\text{root}(\alpha),z)$ 然后 $\texttt{split}(\beta,\text{root}(\beta),y)$，答案不变。也就是说，答案只与我们选择了那些点，又断开了哪些边有关，与我们断开的顺序无关，只要他是合法的。而上面所证，即我们调换点的顺序，也总可以找到合法的方式。</p>
<p>那么贪心的正确性就很容易证明了。</p>
<p>我们可以从点所删除的边出发，也可以从边所对应的点出发。</p>
<p>如果从点删边出发，我们需要求</p>
<h2 id="CF125E"><a href="#CF125E" class="headerlink" title="CF125E"></a><a href="https://codeforces.com/contest/125/problem/E">CF125E</a></h2><p>主要在于输出方案。</p>
<p>我们知道，如果我们所求出的偏移量的最小生成树不是恰好符合要求的，一定是因为有一些 1 出发的边和非 1 出发的边的边权相等，我们优先选择了 1 出发的边，导致选的太多了。那么我们再二分我们优先选择的程度：选择了 <code>kth</code> 条 1 出发的边后就优先选择非 1 出发的边。具体实现看代码。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h4 id="排序和存储方式"><a href="#排序和存储方式" class="headerlink" title="排序和存储方式"></a>排序和存储方式</h4><p>桶排，这样一只 $\log$，而且更方便 <code>krus</code> 中的优先程度修改。</p>
<h4 id="krus"><a href="#krus" class="headerlink" title="krus"></a><code>krus</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">krus</span><span class="params">(<span class="type">int</span> mov,<span class="type">int</span> kth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur,hd0,<span class="built_in">sizeof</span>(hd0));</span><br><span class="line">	<span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="built_in">sizeof</span>(fa));</span><br><span class="line">	<span class="type">int</span> cntk=<span class="number">0</span>,cntb=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mov&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;-mov&amp;&amp;cntb;i++)<span class="keyword">for</span>(<span class="type">int</span> j=hd0[i];j;j=e[j].nxt)<span class="keyword">if</span>(<span class="built_in">merge</span>(e[j].s,e[j].t))++cntk;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,ii=-mov;ii&lt;=<span class="number">100000</span>&amp;&amp;cntb;i++,ii++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> &amp;j=cur[ii];j&amp;&amp;kth&gt;cntk&amp;&amp;cntb;j=e[j].nxt)<span class="keyword">if</span>(<span class="built_in">merge</span>(e[j].s,e[j].t))++cntk,--cntb;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=hd[i];j&amp;&amp;cntb;j=e[j].nxt)cntb-=<span class="built_in">merge</span>(e[j].s,e[j].t);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=cur[ii];j&amp;&amp;cntb;j=e[j].nxt)<span class="keyword">if</span>(<span class="built_in">merge</span>(e[j].s,e[j].t))++cntk,--cntb;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100001</span>+mov;i&lt;=<span class="number">100000</span>&amp;&amp;cntb;i++)<span class="keyword">for</span>(<span class="type">int</span> j=hd[i];j&amp;&amp;cntb;j=e[j].nxt)cntb-=<span class="built_in">merge</span>(e[j].s,e[j].t);</span><br><span class="line">		<span class="keyword">return</span> cntk;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mov&amp;&amp;cntb;i++)<span class="keyword">for</span>(<span class="type">int</span> j=hd[i];j;j=e[j].nxt)cntb-=<span class="built_in">merge</span>(e[j].s,e[j].t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=mov,ii=<span class="number">0</span>;i&lt;=<span class="number">100000</span>&amp;&amp;cntb;i++,ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;j=cur[ii];j&amp;&amp;kth&gt;cntk&amp;&amp;cntb;j=e[j].nxt)<span class="keyword">if</span>(<span class="built_in">merge</span>(e[j].s,e[j].t))++cntk,--cntb;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=hd[i];j&amp;&amp;cntb;j=e[j].nxt)cntb-=<span class="built_in">merge</span>(e[j].s,e[j].t);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=cur[ii];j&amp;&amp;cntb;j=e[j].nxt)<span class="keyword">if</span>(<span class="built_in">merge</span>(e[j].s,e[j].t))++cntk,--cntb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100001</span>-mov;i&lt;=<span class="number">100000</span>&amp;&amp;cntb;i++)<span class="keyword">for</span>(<span class="type">int</span> j=hd0[i];j;j=e[j].nxt)<span class="keyword">if</span>(<span class="built_in">merge</span>(e[j].s,e[j].t))++cntk;</span><br><span class="line">	<span class="keyword">if</span>(cntb)<span class="keyword">return</span> <span class="number">100010</span>;</span><br><span class="line">	<span class="keyword">return</span> cntk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">krus</span>(x,<span class="number">100000</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> -<span class="built_in">krus</span>(mov,x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v,<span class="type">int</span> (&amp;chk)(<span class="type">int</span> x))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid,tmp;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tmp=<span class="built_in">chk</span>(mid);</span><br><span class="line">		<span class="keyword">if</span>(tmp==v)<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;v)l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(so1==m)mov=<span class="number">0</span>;<span class="keyword">else</span> mov=<span class="built_in">binary</span>(<span class="number">-100010</span>,<span class="number">100010</span>,k,chk1);<span class="comment">//so1: 与 1 相连的边数</span></span><br><span class="line"><span class="type">int</span> kth=<span class="built_in">binary</span>(<span class="number">0</span>,so1,-k,chk2)+<span class="number">1</span>,</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>外观数列</title>
    <url>/2021/08/19/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><img src="/2021/08/19/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/1.png" alt="picture 1"></p>
<p><img src="/2021/08/19/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/2.png" alt="picture 2"></p>
<h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><p>注：在以下讨论中将不会考虑 $[ \ ]$ 和 $[2^2]$ 单独出现的乏趣情形。</p>
<p>可以想到将一个长的串分割为数个不相干的段。考虑段之间的情形，即考虑一个段的开头和结尾。</p>
<p>在此之前，对于从 $[a^{\alpha}b^{\beta}\cdots]$ 开始的序列，若<br>$$<br>[a^{\alpha}b^{\beta}\cdots]\to[(a’)^{\alpha’}(b’)^{\beta’}\cdots]<br>$$<br>显然 $\alpha’\le\lfloor\lg\alpha\rfloor+\lfloor\lg\beta\rfloor+3$，故在充分多次操作后串中不可能出现 $X^{\ge4} \ or \ X^3Y^3 \ or\ 3^3$</p>
<p>故，若考虑一个没有 $X^{\ge4} \ or \ X^3Y^3 \ or\ 3^3$ 的串的开头，讨论可能出现的情况：<br>$$<br>[n^m(n\ge4)\to[m^1<br>$$</p>
<p>$$<br>\begin{array}{l}[n^1(n\ge4)\to[1^1X^1\to[1^3\to[3^1X^{(\ne3)}\to[1^1X^1\end{array}<br>$$</p>
<p>$$<br>\begin{array}{l}[1^1X^{\ne1}&amp;\to     &amp;[1^2X^1      &amp;\to&amp;[2^11^2&amp;\to&amp;[1^12^2&amp;\to&amp;[1^2X^{\ne2}\\<br>&amp;\searrow\\<br>                            &amp; &amp;[1^2X^{\ne1}&amp;\to&amp;[2^1X^{\ne2}&amp;\to&amp;[1^1X^1\end{array}<br>$$</p>
<p>$$<br>\begin{array}{l}[2^1X^2\to[1^1X^{\ne1}\end{array}<br>$$</p>
<p>$$<br>\begin{array}{l}[2^3X^{\ne2}\to[3^12^1\end{array}<br>$$</p>
<p>$$<br>[2^3X^2\to[3^12^2<br>$$</p>
<p>$$<br>[3^1\to[1^1<br>$$</p>
<p>$$<br>[3^2\to[2^1<br>$$</p>
<p>除了 $[2^2$，所有的串都将进入 $[1^1X^1\to[1^3\to[3^1X^{(\ne3)}\to[1^1X^1$ 的循环。<br>$$<br>[2^21^1X^1\to[2^21^3\to[2^23^1X^{\ne3}\to[2^21^1X^1<br>$$</p>
<p>$$<br>[2^21^1X^{\ne1}\to[2^21^2\to[2^3<br>$$</p>
<p>$$<br>[2^2X^2\to[2^3<br>$$</p>
<p>$$<br>[2^2(\ne1,\ne2)^1\to[2^21^1<br>$$</p>
<p>另一个循环是 $[2^21^1X^1\to[2^21^3\to[2^23^1X^{\ne3}\to[2^21^1X^1$</p>
<p>进行下一步之前，还需要一个引理：如果一个段是 $n$ 结尾的，那么它永远是 $n$ 结尾的。</p>
<p>现在如果 $[LR]$ 中 $L$ 和 $R$ 是两个独立的段，那么将此串记作 $[L.R]$。表中的 $LR$ 都可记作 $L.R$。</p>
<table>
<thead>
<tr>
<th align="right">$L$</th>
<th align="left">$R$</th>
</tr>
</thead>
<tbody><tr>
<td align="right">$n](n\ge4)$</td>
<td align="left">$[m(m\le3)$</td>
</tr>
<tr>
<td align="right">$2]$</td>
<td align="left">$[n^1 \ or \ [1^1X^1 \ or \ [1^3 \ or \ 3^1X^{(\ne3)}$ （循环 1）</td>
</tr>
<tr>
<td align="right">$\ne2]$</td>
<td align="left">$[2^21^1X^1 \ or \ [2^21^3 \ or\ [2^23^1X^{(\ne3)} \ or \ [2^2] \ or\ [2^2n^1$ （循环 2）</td>
</tr>
</tbody></table>
<p>对于结尾：</p>
<p>$$<br>1^3]\to(\ne2)1^1]\to(\ne2)1^2]\to2^{\ne2}1^1]\to2^{(\ne2)}1^2]\to2^21^1]\to2^21^2]\to2^31^1]<br>$$</p>
<p>对于 $n&gt;1:$</p>
<p><img src="/2021/08/19/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/3.png" alt="picture 3"></p>
<p><img src="/2021/08/19/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/4.png" alt="picture 4"></p>
<p>可以看到在循环中所出现的一些段：<br>$$<br>11132\to 311312\to 1321131112\to 11131221133112\to 311311222.12.32112<br>$$</p>
<p>$$<br>311311222\to1321132.132<br>$$</p>
<p>$$<br>1321132\to111312211312\to3113112221131112\to1321132.13221133112<br>$$</p>
<p>$$<br>13221133112\to1113222.12.32112<br>$$</p>
<p>$$<br>1113222\to311332\to132.12.312<br>$$</p>
<p>$$<br>132\to111312\to31131112\to1321133112\to11131.22.12.32112<br>$$</p>
<p>$$<br>12\to1112\to3112\to132112\to1113122112\to311311222112\to1321132.1322112<br>$$</p>
<p>$$<br>1322112\to1113222112\to3113322112\to132.123222112<br>$$</p>
<p>$$<br>123222112\to111213322112\to31121123222112\to132112211213322112\to111312212221121123222112\to<br>$$</p>
<p>$$<br>3113112211322112211213322112\to1321132122211322212221121123222112\to<br>$$</p>
<p>$$<br>111312211312113221133211322112211213322112\to31131122211311122113222.12.312211322212221121123222112<br>$$</p>
<p>$$<br>31131122211311122113222\to1321132.13221133122211332<br>$$</p>
<p>$$<br>13221133122211332\to1113222.12.3113.22.12.312<br>$$</p>
<p>$$<br>3113\to132113\to1113122113\to311311222113\to1321132.1322113<br>$$</p>
<p>$$<br>1322113\to1113222113\to3113322113\to132.123222113<br>$$</p>
<p>$$<br>123222113\to111213322113\to31121123222113\to132112211213322113\to111312212221121123222113\to<br>$$</p>
<p>$$<br>3113112211322112211213322113\to1321132122211322212221121123222113\to<br>$$</p>
<p>$$<br>111312211312113221133211322112211213322113\to31131122211311122113222.12.312211322212221121123222113<br>$$</p>
<p>$$<br>312211322212221121123222113\to13112221133211322112211213322113\to<br>$$</p>
<p>$$<br>11132.13.22.12.312211322212221121123222113<br>$$</p>
<p>$$<br>13\to1113\to3113<br>$$</p>
<p>$$<br>312211322212221121123222112\to13112221133211322112211213322112\to<br>$$</p>
<p>$$<br>11132.13.22.12.312211322212221121123222112<br>$$</p>
<p>$$<br>312\to131112\to11133112\to312.32112<br>$$</p>
<p>$$<br>32112\to13122112\to111311222112\to31132.1322112<br>$$</p>
<p>$$<br>31132\to13211312\to11131221131112\to3113112221133112\to1321132.13.22.12.32112<br>$$</p>
<p>$$<br>13211322211312113211\to1113122113322113111221131221\to311311222.12322211331222113112211<br>$$</p>
<p>$$<br>12322211331222113112211\to1112133.22.12.311322113212221<br>$$</p>
<p>$$<br>1112133\to3112112.3<br>$$</p>
<p>$$<br>3112112\to1321122112\to11131221222112\to3113112211322112\to13211321222113222112\to<br>$$</p>
<p>$$<br>11131221131211322113322112\to31131122211311122113222.123222112<br>$$</p>
<p>$$<br>3\to13<br>$$</p>
<p>$$<br>311322113212221\to13211322211312113211<br>$$</p>
<p>$$<br>11131\to311311\to13211321\to11131221131211\to311311222113111221\to1321132.1322113312211<br>$$</p>
<p>$$<br>1322113312211\to1113222.12.3112221<br>$$</p>
<p>$$<br>3112221\to132.13211<br>$$</p>
<p>$$<br>13211\to11131221\to3113112211\to132113212221\to111312211312113211\to311311222113111221131221<br>$$</p>
<p>$$<br>\to1321132.132211331222113112211<br>$$</p>
<p>$$<br>132211331222113112211\to1113222.12.311322113212221<br>$$</p>
<p>$$<br>311322113212221\to13211322211312113211<br>$$</p>
<p>整理可得 92 个基本串，即元素：</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Subsequence</th>
<th align="center">Len</th>
<th align="center"><strong>Evolves Into</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1112</td>
<td align="center">4</td>
<td align="center">(63)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1112133</td>
<td align="center">7</td>
<td align="center">(64)(62)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">111213322112</td>
<td align="center">12</td>
<td align="center">(65)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">111213322113</td>
<td align="center">12</td>
<td align="center">(66)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">1113</td>
<td align="center">4</td>
<td align="center">(68)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">11131</td>
<td align="center">5</td>
<td align="center">(69)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">111311222112</td>
<td align="center">12</td>
<td align="center">(84)(55)</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">111312</td>
<td align="center">6</td>
<td align="center">(70)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">11131221</td>
<td align="center">8</td>
<td align="center">(71)</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">1113122112</td>
<td align="center">10</td>
<td align="center">(76)</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">1113122113</td>
<td align="center">10</td>
<td align="center">(77)</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">11131221131112</td>
<td align="center">14</td>
<td align="center">(82)</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">111312211312</td>
<td align="center">12</td>
<td align="center">(78)</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">11131221131211</td>
<td align="center">14</td>
<td align="center">(79)</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">111312211312113211</td>
<td align="center">18</td>
<td align="center">(80)</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">111312211312113221133211322112211213322112</td>
<td align="center">42</td>
<td align="center">(81)(29)(90)</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">111312211312113221133211322112211213322113</td>
<td align="center">42</td>
<td align="center">(81)(29)(91)</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">11131221131211322113322112</td>
<td align="center">26</td>
<td align="center">(81)(30)</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">11131221133112</td>
<td align="center">14</td>
<td align="center">(75)(29)(92)</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">1113122113322113111221131221</td>
<td align="center">28</td>
<td align="center">(75)(32)</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">11131221222112</td>
<td align="center">14</td>
<td align="center">(72)</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">111312212221121123222112</td>
<td align="center">24</td>
<td align="center">(73)</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">111312212221121123222113</td>
<td align="center">24</td>
<td align="center">(74)</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">11132</td>
<td align="center">5</td>
<td align="center">(83)</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center">1113222</td>
<td align="center">7</td>
<td align="center">(86)</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">1113222112</td>
<td align="center">10</td>
<td align="center">(87)</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center">1113222113</td>
<td align="center">10</td>
<td align="center">(88)</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">11133112</td>
<td align="center">8</td>
<td align="center">(89)(92)</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">12</td>
<td align="center">2</td>
<td align="center">(1)</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">123222112</td>
<td align="center">9</td>
<td align="center">(3)</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">123222113</td>
<td align="center">9</td>
<td align="center">(4)</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">12322211331222113112211</td>
<td align="center">23</td>
<td align="center">(2)(61)(29)(85)</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">13</td>
<td align="center">2</td>
<td align="center">(5)</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center">131112</td>
<td align="center">6</td>
<td align="center">(28)</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center">13112221133211322112211213322112</td>
<td align="center">32</td>
<td align="center">(24)(33)(61)(29)(90)</td>
</tr>
<tr>
<td align="center">36</td>
<td align="center">13112221133211322112211213322113</td>
<td align="center">32</td>
<td align="center">(24)(33)(61)(29)(91)</td>
</tr>
<tr>
<td align="center">37</td>
<td align="center">13122112</td>
<td align="center">8</td>
<td align="center">(7)</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center">132</td>
<td align="center">3</td>
<td align="center">(8)</td>
</tr>
<tr>
<td align="center">39</td>
<td align="center">13211</td>
<td align="center">5</td>
<td align="center">(9)</td>
</tr>
<tr>
<td align="center">40</td>
<td align="center">132112</td>
<td align="center">6</td>
<td align="center">(10)</td>
</tr>
<tr>
<td align="center">41</td>
<td align="center">1321122112</td>
<td align="center">10</td>
<td align="center">(21)</td>
</tr>
<tr>
<td align="center">42</td>
<td align="center">132112211213322112</td>
<td align="center">18</td>
<td align="center">(22)</td>
</tr>
<tr>
<td align="center">43</td>
<td align="center">132112211213322113</td>
<td align="center">18</td>
<td align="center">(23)</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center">132113</td>
<td align="center">6</td>
<td align="center">(11)</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center">1321131112</td>
<td align="center">10</td>
<td align="center">(19)</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">13211312</td>
<td align="center">8</td>
<td align="center">(12)</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center">1321132</td>
<td align="center">7</td>
<td align="center">(13)</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">13211321</td>
<td align="center">8</td>
<td align="center">(14)</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">132113212221</td>
<td align="center">12</td>
<td align="center">(15)</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">13211321222113222112</td>
<td align="center">20</td>
<td align="center">(18)</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">1321132122211322212221121123222112</td>
<td align="center">34</td>
<td align="center">(16)</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">1321132122211322212221121123222113</td>
<td align="center">34</td>
<td align="center">(17)</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">13211322211312113211</td>
<td align="center">20</td>
<td align="center">(20)</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">1321133112</td>
<td align="center">10</td>
<td align="center">(6)(61)(29)(92)</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">1322112</td>
<td align="center">7</td>
<td align="center">(26)</td>
</tr>
<tr>
<td align="center">56</td>
<td align="center">1322113</td>
<td align="center">7</td>
<td align="center">(27)</td>
</tr>
<tr>
<td align="center">57</td>
<td align="center">13221133112</td>
<td align="center">11</td>
<td align="center">(25)(29)(92)</td>
</tr>
<tr>
<td align="center">58</td>
<td align="center">1322113312211</td>
<td align="center">13</td>
<td align="center">(25)(29)(67)</td>
</tr>
<tr>
<td align="center">59</td>
<td align="center">132211331222113112211</td>
<td align="center">21</td>
<td align="center">(25)(29)(85)</td>
</tr>
<tr>
<td align="center">60</td>
<td align="center">13221133122211332</td>
<td align="center">17</td>
<td align="center">(25)(29)(68)(61)(29)(89)</td>
</tr>
<tr>
<td align="center">61</td>
<td align="center">22</td>
<td align="center">2</td>
<td align="center">(61)</td>
</tr>
<tr>
<td align="center">62</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">(33)</td>
</tr>
<tr>
<td align="center">63</td>
<td align="center">3112</td>
<td align="center">4</td>
<td align="center">(40)</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">3112112</td>
<td align="center">7</td>
<td align="center">(41)</td>
</tr>
<tr>
<td align="center">65</td>
<td align="center">31121123222112</td>
<td align="center">14</td>
<td align="center">(42)</td>
</tr>
<tr>
<td align="center">66</td>
<td align="center">31121123222113</td>
<td align="center">14</td>
<td align="center">(43)</td>
</tr>
<tr>
<td align="center">67</td>
<td align="center">3112221</td>
<td align="center">7</td>
<td align="center">(38)(39)</td>
</tr>
<tr>
<td align="center">68</td>
<td align="center">3113</td>
<td align="center">4</td>
<td align="center">(44)</td>
</tr>
<tr>
<td align="center">69</td>
<td align="center">311311</td>
<td align="center">6</td>
<td align="center">(48)</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">31131112</td>
<td align="center">8</td>
<td align="center">(54)</td>
</tr>
<tr>
<td align="center">71</td>
<td align="center">3113112211</td>
<td align="center">10</td>
<td align="center">(49)</td>
</tr>
<tr>
<td align="center">72</td>
<td align="center">3113112211322112</td>
<td align="center">16</td>
<td align="center">(50)</td>
</tr>
<tr>
<td align="center">73</td>
<td align="center">3113112211322112211213322112</td>
<td align="center">28</td>
<td align="center">(51)</td>
</tr>
<tr>
<td align="center">74</td>
<td align="center">3113112211322112211213322113</td>
<td align="center">28</td>
<td align="center">(52)</td>
</tr>
<tr>
<td align="center">75</td>
<td align="center">311311222</td>
<td align="center">9</td>
<td align="center">(47)(38)</td>
</tr>
<tr>
<td align="center">76</td>
<td align="center">311311222112</td>
<td align="center">12</td>
<td align="center">(47)(55)</td>
</tr>
<tr>
<td align="center">77</td>
<td align="center">311311222113</td>
<td align="center">12</td>
<td align="center">(47)(56)</td>
</tr>
<tr>
<td align="center">78</td>
<td align="center">3113112221131112</td>
<td align="center">16</td>
<td align="center">(47)(57)</td>
</tr>
<tr>
<td align="center">79</td>
<td align="center">311311222113111221</td>
<td align="center">18</td>
<td align="center">(47)(58)</td>
</tr>
<tr>
<td align="center">80</td>
<td align="center">311311222113111221131221</td>
<td align="center">24</td>
<td align="center">(47)(59)</td>
</tr>
<tr>
<td align="center">81</td>
<td align="center">31131122211311122113222</td>
<td align="center">23</td>
<td align="center">(47)(60)</td>
</tr>
<tr>
<td align="center">82</td>
<td align="center">3113112221133112</td>
<td align="center">16</td>
<td align="center">(47)(33)(61)(29)(92)</td>
</tr>
<tr>
<td align="center">83</td>
<td align="center">311312</td>
<td align="center">6</td>
<td align="center">(45)</td>
</tr>
<tr>
<td align="center">84</td>
<td align="center">31132</td>
<td align="center">5</td>
<td align="center">(46)</td>
</tr>
<tr>
<td align="center">85</td>
<td align="center">311322113212221</td>
<td align="center">15</td>
<td align="center">(53)</td>
</tr>
<tr>
<td align="center">86</td>
<td align="center">311332</td>
<td align="center">6</td>
<td align="center">(38)(29)(89)</td>
</tr>
<tr>
<td align="center">87</td>
<td align="center">3113322112</td>
<td align="center">10</td>
<td align="center">(38)(30)</td>
</tr>
<tr>
<td align="center">88</td>
<td align="center">3113322113</td>
<td align="center">10</td>
<td align="center">(38)(31)</td>
</tr>
<tr>
<td align="center">89</td>
<td align="center">312</td>
<td align="center">3</td>
<td align="center">(34)</td>
</tr>
<tr>
<td align="center">90</td>
<td align="center">312211322212221121123222112</td>
<td align="center">27</td>
<td align="center">(35)</td>
</tr>
<tr>
<td align="center">91</td>
<td align="center">312211322212221121123222113</td>
<td align="center">27</td>
<td align="center">(36)</td>
</tr>
<tr>
<td align="center">92</td>
<td align="center">32112</td>
<td align="center">5</td>
<td align="center">(37)</td>
</tr>
</tbody></table>
<p>定义一个向量 $\vec{v}$，向量的第 $n$ 项为当前串中第 $n$ 个元素的个数。则下一个串为：<br>$$<br>\vec{v}’=A\vec{v},\vec{v_n}=A^n\vec{v_0}<br>$$<br>其中 $A$ 为一个矩阵，如果 $(i)$ 能产生 $x$ 个 $(j)$，则第 $i$ 列第 $j$ 行为 $x$。</p>
<p>再定义一个向量 $\vec{u}$，其第 $i$ 项代表 $len(i)$。则<br>$$<br>L=\vec{u}\cdot\vec{v}<br>$$<br>设矩阵 $A$ 绝对值最大的特征值为 $\lambda_0$ ，<br>$$<br>\vec{v}=A^n\vec{v_0}=A^n\left(a_0\vec{w_0}+\cdots+a_k\vec{w_k}+\cdots\right)=\lambda_0^n\left(a\vec{w_0}+a_1\cdot\left(\frac{\lambda_1}{\lambda_0}\right)^n\vec{w_1}+\cdots\right)<br>$$</p>
<p>根据 Perron–Frobenius 定理，$\forall k&gt;0,|\lambda_k|&lt;|\lambda_0|$，故有</p>
<p>$$<br>\lim_{n\to+\infty}\left(\frac{\lambda_k}{\lambda_0}\right)^n=0,\lim_{n\to+\infty}A^n\vec{v_0}=\lambda_0^na\vec{w_0}<br>$$<br>因此 Conway 常数 $\lambda=\lambda_0$。</p>
<p>可得方程</p>
<p>$$<br>x^{71}-x^{69}-2x^{68}-x^{67}+2x^{66}+2x^{65}+x^{64}-x^{63}-x^{62}-x^{61}-x^{60}-x^{59}+2x^{58}+5x^{57}+3x^{56}-2x^{55}-10x^{54}-3x^{53}-2x^{52}+6x^{51}+6x^{50}+x^{49}+9x^{48}-3x^{47}-7x^{46}-8x^{45}-8x^{44}+10x^{43}+6x^{42}+8x^{41}-5x^{40}-12x^{39}+7x^{38}-7x^{37}+7x^{36}-x^{35}-3x^{34}+10x^{33}+x^{32}-6x^{31}-2x^{30}-10x^{29}-3x^{28}+2x^{27}+9x^{26}-3x^{25}+14x^{24}-8x^{23}-7x^{21}+9x^{20}+3x^{19}-4x^{18}-10x^{17}-7x^{16}+12x^{15}+7x^{14}+2x^{13}-12x^{12}-4x^{11}<br>-2x^{10}+5x^{9}+x^{7}-7x^{6}+7x^{5}-4x^{4}+12x^{3}-6x^{2}+3x-6=0<br>$$</p>
<p>可解得 $\lambda\approx1.3035772690342963912570991121525498$</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>序列合并</title>
    <url>/2022/02/13/%E5%BA%8F%E5%88%97%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2022/02/13/%E5%BA%8F%E5%88%97%E5%90%88%E5%B9%B6/1.png"></p>
<p>$1&lt;n,m\le 10^3,m\le t\le 10^9$</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑序列的第一位，如果该位确定，那么问题转化为求 $n-1$ 位问题。但这 $n-1$ 位中第一位可能会与整个序列第一位发生合并。<strong>我们更希望出现的情况是</strong>第一位确定。故设 $p_{i,j}$ 为限制长度为 $i$，首位出现过 $j$ 的概率，即当该序列之前是 $j$ 时发生合并的概率，而在出现了 $j$ 前提下首位保持不变的概率为 $q_{i,j}$。如果第一位保持为 $j$，相当于有后 $i-1$ 位的首位未出现过 $j$，即 $q_{i,j}=1-p_{i-1,j}$。（$j=t$ 时特判，下文不再重复）</p>
<p>当第一位出现了 $j$ 时，可能有两种情况：</p>
<ol>
<li>两个 $j-1$ 合并，即 $p_{i,j-1}\cdot p_{i-1,j-1}$</li>
<li>直接加入 $j$，概率 $\frac{1}{m}$</li>
</ol>
<p>在第一位保持为 $j$ 的情况下考虑求解：设以此为前提，期望和为 $g_{i,j}$，则 $ans_i=\sum_{j=1}^{lim}p_{i,j}q_{i,j}g_{i,j}$。设 $f_{i,j}$ 为第一位产生 $j$ 前提下期望和，有：<br>$$<br>g_{i,j}=j+\frac{ans_{i-1}-p_{i-1,j}f_{i-1,j}}{q_{i,j}}<br>$$<br>考虑求 $f$。讨论 $j$ 是否保持不变，得：<br>$$<br>f_{i,j}=q_{i,j}g_{i,j}+(1-q_{i,j})f_{i,j+1}<br>$$<br>显然 $lim=\min(n+m-1,t)$，时间复杂度 $O(nm\log(10^9+7))$。但如果不求 $g_{i,j}$，而是求 $q_{i,j}g_{i,j}$，则可以做到 $O(nm)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> p[<span class="number">1001</span>][<span class="number">2001</span>],q[<span class="number">1001</span>][<span class="number">2001</span>],g[<span class="number">2001</span>],f[<span class="number">2001</span>],ans;</span><br><span class="line"><span class="type">int</span> m,n,t,lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ret=<span class="number">1LL</span>*ret*x%mod;</span><br><span class="line">		x=<span class="number">1LL</span>*x*x%mod;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;sequence.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	lim=<span class="built_in">min</span>(n+m<span class="number">-1</span>,t);</span><br><span class="line">	<span class="type">int</span> m_1=<span class="built_in">pow</span>(m,mod<span class="number">-2</span>),an;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)p[i][j]=(<span class="number">1LL</span>*p[i][j<span class="number">-1</span>]*p[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1LL</span>*(j&lt;=m)*m_1)%mod,q[i][j]=(<span class="number">1</span>-(j&lt;lim)*p[i<span class="number">-1</span>][j]+mod)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)g[i]=f[i]=i,ans=(<span class="number">1LL</span>*p[<span class="number">1</span>][i]*q[<span class="number">1</span>][i]%mod*i+ans)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		an=ans;ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> _=an-(j&lt;lim?<span class="number">1LL</span>*p[i<span class="number">-1</span>][j]*f[j]%mod:<span class="number">0</span>)+mod;</span><br><span class="line">			g[j]=(<span class="number">1LL</span>*q[i][j]*j+_)%mod;ans=(<span class="number">1LL</span>*p[i][j]*g[j]%mod+ans)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=lim;j;j--)f[j]=(<span class="number">1LL</span>*g[j]%mod+<span class="number">1LL</span>*(<span class="number">1</span>-q[i][j]+mod)*f[j+<span class="number">1</span>]%mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>如果发现无法直接转移，不妨把所需的辅助变量都设出来，多个量一起递推。</p>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>数论（1）</title>
    <url>/2021/10/02/%E6%95%B0%E8%AE%BA%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>若 $p$ 为质数，$a$ 不是 $p$ 的倍数，则 $a^{p-1}\equiv 1(\mod p)$</p>
<p>证明：</p>
<p>$0&lt;t&lt;p,ta$ 在 $\mod p$ 下互不相同，因为如果 $t\neq k,ta\equiv ka(\mod p),t\equiv k(\mod p)$</p>
<p>故 $a^{p-1}(p-1)!\equiv(p-1)!(\mod p),a^{p-1}\equiv 1(\mod p)$</p>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>任意 $\gcd(m,n)=1$，有 $f(m)f(n)=f(mn)$，则 $f(x)$ 为积性函数。特殊地，若对任意 $m,n$ 都有 $f(m)f(n)=f(mn)$，则 $f(x)$ 为完全积性函数。</p>
<p>注：常见的积性函数：</p>
<ul>
<li>$\epsilon(x)=[x=1]$</li>
<li>$1(n)=1$</li>
<li>$id_k(n)=n^k$</li>
<li>$\sigma_k(n)=\sum_{d|n}d^k$</li>
<li>$\varphi(n)$：一会要说的欧拉函数</li>
<li>$\mu(n)$：以后会说的莫比乌斯函数</li>
</ul>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\varphi(n)$ 为不超过 $n$ 且与 $n$ 互素的正整数的个数。</p>
<ul>
<li><p>$p 为素数\Leftrightarrow\varphi(p)=p-1$</p>
</li>
<li><p>$\sum_{d|m}\varphi\left(\frac{m}{d}\right)=m$<br>$$<br>\varphi(m)=\sum_{i=1}^m[\gcd(m,i)=1]=m-\sum_{d|m,d\ne1}\sum_{i=d}^m[\gcd(m,i)=d]<br>$$</p>
<p>$$<br>=m-\sum_{d|m,d\ne1}\sum_{d|i}^m\left[\gcd\left(\frac{m}{d},\frac{i}{d}\right)=1\right]<br>$$</p>
<p>$$<br>=m-\sum_{d|m,d\ne1}\varphi\left(\frac{m}{d}\right),\therefore\sum_{d|m}\varphi\left(\frac{m}{d}\right)=m<br>$$</p>
</li>
<li><p>$\gcd(m,n)=1,\varphi(m)\varphi(n)=\varphi(mn)$<br>$$<br>\varphi(m)=\sum_{i=1}^m[\gcd(m,i)=1],\varphi(mn)=\sum_{i=1}^{mn}[\gcd(mn,i)=1]<br>$$</p>
<p>$$<br>=\sum_{i=1}^{mn}[\gcd(m,i)=1]\cdot[\gcd(n,i)=1]<br>$$</p>
<p>$$<br>=\sum_{i=1}^{mn}[\gcd(m,i\mod m)=1][\gcd(n,i\mod n)=1]<br>$$</p>
<p>$$<br>=\sum_{i=1}^m\left([\gcd(m,i)=1]\sum_{j=0}^{n-1}[\gcd(n,(mj+i)\mod n)=1] \right)<br>$$</p>
<p>$$<br>=\sum_{i=1}^m\left([\gcd(m,i)=1]\sum_{j=1}^{n}[\gcd(n,j)=1] \right)<br>$$</p>
<p>$$<br>=\sum_{i=1}^m[\gcd(m,i)=1]\sum_{j=1}^{n}[\gcd(n,j)=1]=\varphi(m)\varphi(n)<br>$$</p>
<p>因此，欧拉函数是积性函数。</p>
</li>
</ul>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若 $\gcd(a,m)=1$，则 $a^{\varphi(m)}\equiv1(\mod m)$</p>
<p>证明与费马小定理类似。</p>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>数论（2）</title>
    <url>/2021/10/24/%E6%95%B0%E8%AE%BA%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="欧拉定理的推广"><a href="#欧拉定理的推广" class="headerlink" title="欧拉定理的推广"></a>欧拉定理的推广</h2><p>欧拉定理要求 $\gcd(a,m)=1$，因此在 $a,m$ 不互质时无法直接使用。对于 $a,m$，若 $gcd(m,a)\ne 1$ 且 $x&gt;\varphi(m)$，有<br>$$<br>a^x\equiv a^{x\mod\varphi(m)+\varphi(m)}\mod m<br>$$<br>证明：<br>$$<br>m=\prod_{i=1}^{n}p_i^{q_i},a=s\prod_{i=1}^{n}p_i^{k_i},\gcd(s,m)=1<br>$$</p>
<p>$$<br>即证:t\ge1,a^{t\varphi(m)}\equiv s^{t\varphi(m)}\prod_{i=1}^{n}p_i^{t\varphi(m)k_i}\equiv a^{\varphi(m)}\mod m<br>$$</p>
<p>$$<br>对于 k_i=0,p_i^{t\varphi(m)k_i}\equiv1\mod m<br>$$</p>
<p>$$<br>\varphi(m)\ge\varphi(p_i^{q_i})=p_i^{q_i-1}(p_i-1)\ge2^{q_i-1}\ge q_i<br>$$</p>
<p>$$<br>p_i^{b\varphi(m)}\equiv1 \mod \left(\frac{m}{p_i^{q_i}}\right),p_i^{b\varphi(m)+q_i}\equiv p_i^{q_i}\mod m<br>$$</p>
<p>$$<br>p_i^{(b+1)\varphi(m)}\equiv p_i^{\varphi(m)}\mod m<br>$$</p>
<p>显然，原命题成立。</p>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><a href="https://www.luogu.com.cn/problem/P4139">P4139 上帝与集合的正确用法</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>$$<br>2^{2^{2\cdots}}\equiv 2^{\left(2^{2\cdots}\mod\varphi(p)+\varphi(p)\right)}\equiv2^{\left(2^{\left(2^{2\cdots}\mod\varphi(\varphi(p))+\varphi(\varphi(p))\right)}\mod\varphi(p)+\varphi(p)\right)}\mod p<br>$$</p>
<p>当 $\varphi(\varphi(\cdots\varphi(p)))=1$ 时，在往上的 $2$ 就对答案没有影响了，而容易看出，这些 $2$ 最多有 $\log$ 层。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll t,p;</span><br><span class="line">ll pri[<span class="number">700000</span>],phi[<span class="number">10000001</span>],cnt;</span><br><span class="line"><span class="type">bool</span> ntpr[<span class="number">10000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(!ntpr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;=<span class="number">10000000</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ntpr[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!(i%pri[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i*pri[j]]=phi[i]*pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i*pri[j]]=phi[i]*phi[pri[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">quik_pow</span><span class="params">(ll a,ll b,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret=<span class="number">1</span>,_=a;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret*=_,ret%=mod;</span><br><span class="line">        _=_*_,_%=mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solv</span><span class="params">(ll _)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quik_pow</span>(<span class="number">2LL</span>,<span class="built_in">solv</span>(phi[_])+phi[_],_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        t--;</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">solv</span>(p)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>OI</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>特征根法与特征值</title>
    <url>/2021/08/06/%E7%89%B9%E5%BE%81%E6%A0%B9%E6%B3%95%E4%B8%8E%E7%89%B9%E5%BE%81%E5%80%BC/</url>
    <content><![CDATA[<h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p>对于数列 $a_n=pa_{n-1}+qa_{n-2}$，已知 $a_1,a_2$，求通项公式。</p>
<p>对于此类问题，基本的思想是在等式两边制造同构。不妨设同构的部分是 $a_n-ta_{n-1}$，则：<br>$$<br>a_n-ta_{n-1}=(p-t)(a_{n-1}-ta_{n-2})-(t^2-pt-q)a_{n-2}<br>$$</p>
<p>$$<br>\therefore t^2-pt-q=0<br>$$<br>$t^2-pt-q=0$ 称为数列 ${a_n}$ 的特征方程，其根称为 ${a_n}$ 的特征根。</p>
<p>如果方程有不等两根（<strong>不是实根也可以</strong>），那么将推出的两个式子（分别用两根推出 $a_n-ta_{n-1}$ 的通项）作差，消去 $a_n$ 项。</p>
<p>若方程两根相等，则 $t=\frac{p}{2},p-t=t$，最后可以整理出 $\frac{a_n}{t^n}$ 是等差数列。</p>
<hr>
<h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p>特征根法同时也是解常系数齐次线性微分方程的方法。</p>
<p>对于 $y’’-py’-qy=0$，设 $y’’-ry’=(p-r)(y’-ry’’)$，则 $r^2-pr-q=0$。</p>
<p>若 $r_1\neq r_2,y=c_1e^{r_1x}+c_2e^{r_2x}$</p>
<p>$r_1=r_2,y=(c_1+c_2x)e^{rx}$</p>
<p>若有两复根 $a\pm bi,y=e^{ax}(c_1\cos bx+c_2\sin bx)$</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>一方面，两者的思想都在于构造同构；另一方面，事实上，对于 $a_n=pa_{n-1}+qa_{n-2}$，<br>$$<br>A_n=\left[\begin{array}{l}a_n\\a_{n-1}\end{array}\right],A_n=\left[\begin{array}{l}p&amp;q\\1&amp;0\end{array}\right]\times A_{n-1}=\left[\begin{array}{l}p&amp;q\\1&amp;0\end{array}\right]^{n-2}\times\left[\begin{array}{l}a_2\\a_1\end{array}\right]<br>$$</p>
<p>$$<br>(\lambda-p)\lambda=q,\lambda^2-p\lambda-q=0.<br>$$<br>数列的特征根事实上是它所对应的矩阵的特征值。我们可以将 $\left[\begin{array}{l}a_2\\a_1\end{array}\right]$ 用两个特征向量表示（易知如果 $\lambda_1=\lambda_2$，那么 $\left[\begin{array}{l}a_2\\a_1\end{array}\right]$ 和 $\lambda$ 在同一直线上）本质上，这种作法是将一个向量的旋转和伸缩转化为在特征向量方向的伸缩。</p>
<p>对于 $y’’-py’-qy=0$，<br>$$<br>\left[\begin{array}{l}p&amp;q\\1&amp;0\end{array}\right]\times \left[\begin{array}{l}y’\\y\end{array}\right]=\left[\begin{array}{l}y’’\\y’\end{array}\right]<br>$$</p>
<p>$$<br>\left[\begin{array}{l}y’\\y\end{array}\right]=e^{\left[\begin{array}{l}p&amp;q\\1&amp;0\end{array}\right]x}\left[\begin{array}{l}y_0’\\y_0\end{array}\right]<br>$$<br>类比刚才的想法，将 $\left[\begin{array}{l}y_0’\\y_0\end{array}\right]$ 转化成特征向量来表示。</p>
<p>矩阵本质上是对信息的组合加以抽象的产物。由于有更高的抽象程度，它可以被赋予更多的含义，找到不同事物的共同结构特点。同时无论是哪种方法其思想都在于构造统一的表示方法，可见抽象与统一大概是数学之魂吧。</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法感性理解</title>
    <url>/2022/04/28/%E7%AE%97%E6%B3%95%E6%84%9F%E6%80%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文主要是对于一些算法的更为直观或感性的理解，持续更新。</p>
<p>本文按作者想到的时间顺序排列，与算法类别和难度无关。</p>
<h2 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h2><h3 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h3><p>何为容斥？容斥处理集合的交或并。自然，这可以是多个条件的与或或。</p>
<h3 id="Min-与-Max-的分解"><a href="#Min-与-Max-的分解" class="headerlink" title="Min 与 Max 的分解"></a>Min 与 Max 的分解</h3><p>Min 和 Max 属于比较严格的限制了（严格到只有一个啊）。那么我们就分解他。</p>
<p>先看看 Min。Min 意味着这个数 $\le$ 所有的数。然而这样限制出来，得到的是所有 $\le$ Min 的数。不过这样形式倒是统一。</p>
<p>那么我们令 $f(x)$ 为 $\le x$ 的数的集合。为了方便，所有数都是正数，这样 $f^{-1}(V)=\left|V\right|$。</p>
<p>那么：<br>$$<br>\max(S)=\left|\bigcup_{x\in S} f(x)\right|=\sum_{T\subseteq S}\left((-1)^{\left|T\right|+1}<br>\left|\bigcap_{x\in T}f(x)\right|\right)=\sum_{T\subseteq S}(-1)^{\left|T\right|+1}\min(T)<br>$$<br>Min 同样。</p>
<h2 id="WQS-二分"><a href="#WQS-二分" class="headerlink" title="WQS 二分"></a>WQS 二分</h2><p>问题：一堆物品，每个有价值。取 k 个，有限制，求最大价值。</p>
<p>如果 f[i][j] 表示状态 DP，到 i 位，已经取 j 个，状态都两维大概也没法更优。</p>
<p>另一种思路是贪心。如果限制性质比较好可以给贪心加个反悔，比如<a href="https://www.luogu.com.cn/problem/P1484">P1484 种树</a>。</p>
<p>DP 如果要优化必须降维。你不能把 DP 到哪这维去了，那就只能去已经取多少个。那就不能考虑个数限制了，只能在 DP 之外来体现。</p>
<p>要是求完正好 k 个那可太好了，要是不是？</p>
<p>我怎么影响最优解的选的个数呢？我要是给选的个数一个附加的代价，这个代价大个数少，代价小个数多。</p>
<p>那么给每一个物品的价值加个常数 c，二分他，直到你正好选了 k 个。</p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://pufanyi.github.io/%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8/Train2012-sol-wqs.pdf">Train2012-sol-wqs.pdf</a> 其实 wqs 本人论文里说得挺明白的。</p>
]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>树上移动</title>
    <url>/2022/03/06/%E6%A0%91%E4%B8%8A%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2022/03/06/%E6%A0%91%E4%B8%8A%E7%A7%BB%E5%8A%A8/1.png"></p>
<p>$n\le 10^5$。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，考虑每一个点的贡献：每一个点被选择后，如果不终止，一定随机选择下一个点，计算这之间的期望路径长度（树形 DP）。这样，我们只需计算每个点期望被选择的次数。此时该问题只与节点的值有关。</p>
<p>当已有 $i$ 个点为 $1$ 时，选择值为 $0/1$ 的点的期望次数为：<br>$$<br>f_{i,0}=\frac{1}{n}+\frac{f_{i+1,1}}{n}+\frac{i\cdot f_{i-1,0}}{n}+\frac{(n-i-1)f_{i+1,0}}{n}<br>$$</p>
<p>$$<br>f_{i,1}=\frac{1}{n}+\frac{f_{i-1,0}}{n}+\frac{(i-1)f_{i-1,1}}{n}+\frac{(n-i)f_{i+1,1}}{n}<br>$$</p>
<p>整理可得，<br>$$<br>(n-i-1)f_{i+1,0}+f_{i+1,1}=n\cdot f_{i,0}-1-i\cdot f_{i-1,0}<br>$$</p>
<p>$$<br>f_{i+1,1}=\frac{n\cdot f_{i,1}-1-f_{i-1,0}-(i-1)f_{i-1,1}}{n-i}<br>$$</p>
<p>我们用 $f_{1,0/1}$ 来表示每一个 $f$，用 $f_{n-1,0/1}$ 的转移列出方程。</p>
<p>边界：<br>$$<br>f_{0,0/1}=f_{n,0/1}=0<br>$$<br>另外，$f_{1,1}$ 和 $f_{n-1,0}$ 的转移没有 $\frac{1}{n}$ 这一项，因为此时选择的这个点是没有贡献的（选择了就结束了，而贡献是<strong>选择后转移走的次数</strong>）。</p>
<p>详见代码。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll ny[<span class="number">100001</span>];</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span></span><br><span class="line">&#123;</span><br><span class="line">	ll a,b,c;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">val</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> (a*x+b*y+c)%mod;&#125;</span><br><span class="line">&#125;f[<span class="number">100001</span>][<span class="number">2</span>];</span><br><span class="line">F <span class="keyword">operator</span> + (F f1,F f2)</span><br><span class="line">&#123;</span><br><span class="line">	f1.a=(f1.a+f2.a)%mod,f1.b=(f1.b+f2.b)%mod,f1.c=(f1.c+f2.c)%mod;</span><br><span class="line">	<span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line">F <span class="keyword">operator</span> - (F f1,F f2)</span><br><span class="line">&#123;</span><br><span class="line">	f1.a=f1.a-f2.a,f1.b=f1.b-f2.b,f1.c=f1.c-f2.c;</span><br><span class="line">	f1.a=(f1.a+mod)%mod;f1.b=(f1.b+mod)%mod;f1.c=(f1.c+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line">F <span class="keyword">operator</span> + (F _,ll x)</span><br><span class="line">&#123;</span><br><span class="line">	_.c=(_.c+x)%mod;</span><br><span class="line">	<span class="keyword">return</span> _;</span><br><span class="line">&#125;</span><br><span class="line">F <span class="keyword">operator</span> - (F _,ll x)</span><br><span class="line">&#123;</span><br><span class="line">	_.c=((_.c-x)%mod+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> _;</span><br><span class="line">&#125;</span><br><span class="line">F <span class="keyword">operator</span> * (ll x,F _)</span><br><span class="line">&#123;</span><br><span class="line">	_.a=_.a*x%mod,_.b=_.b*x%mod,_.c=_.c*x%mod;</span><br><span class="line">	<span class="keyword">return</span> _;</span><br><span class="line">&#125;</span><br><span class="line">F <span class="keyword">operator</span> / (F _,ll x)</span><br><span class="line">&#123;</span><br><span class="line">	x=ny[x],_.a=_.a*x%mod,_.b=_.b*x%mod,_.c=_.c*x%mod;</span><br><span class="line">	<span class="keyword">return</span> _;</span><br><span class="line">&#125;<span class="comment">//以 f[1][0],f[1][1] 表示 f=a*f[1][0]+b*f[1][1]+c</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qkp</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ret=<span class="number">1LL</span>,_=x;</span><br><span class="line">	<span class="keyword">while</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ret=ret*_%mod;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		_=_*_%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mp[<span class="number">100000</span>];ll dis[<span class="number">100001</span>],n,fa[<span class="number">100001</span>];</span><br><span class="line">vector &lt;ll&gt; son[<span class="number">100001</span>];</span><br><span class="line">ll sz[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i:son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">		sz[x]+=sz[i];</span><br><span class="line">		dis[x]+=dis[i]+sz[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i:son[x])</span><br><span class="line">	&#123;</span><br><span class="line">	dis[i]+=dis[x]-dis[i]+n-(sz[i]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">dfs2</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> ntpr[<span class="number">100001</span>];ll pr[<span class="number">100001</span>],tnc=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;c.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;c.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp);</span><br><span class="line">	ll cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cnt+=(mp[i]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;fa[i]),son[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1LL</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1LL</span>);</span><br><span class="line">	ny[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!ntpr[i])pr[++tnc]=i,ny[i]=<span class="built_in">qkp</span>(i,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tnc&amp;&amp;pr[j]*i&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ny[pr[j]*i]=ny[i]*ny[pr[j]]%mod;</span><br><span class="line">			ntpr[pr[j]*i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!i%pr[j])<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//类比欧拉筛求逆元，其实暴力也可以过</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=dis[i]%mod*ny[n]%mod;<span class="comment">//树形 DP</span></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>].a=<span class="number">1LL</span>,f[<span class="number">1</span>][<span class="number">1</span>].b=<span class="number">1LL</span>;<span class="comment">//初始值</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i][<span class="number">1</span>]=(n*f[i<span class="number">-1</span>][<span class="number">1</span>]-(ll)(i&gt;<span class="number">2LL</span>)-f[i<span class="number">-2</span>][<span class="number">0</span>]-(i<span class="number">-2</span>)*f[i<span class="number">-2</span>][<span class="number">1</span>])/(n-i+<span class="number">1</span>);</span><br><span class="line">		f[i][<span class="number">0</span>]=n*f[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">-1LL</span>-(i<span class="number">-1</span>)*f[i<span class="number">-2</span>][<span class="number">0</span>];</span><br><span class="line">		f[i][<span class="number">0</span>]=(f[i][<span class="number">0</span>]-f[i][<span class="number">1</span>])/(n-i);</span><br><span class="line">	&#125;<span class="comment">//递推</span></span><br><span class="line">	ll s1,s2,s3,s4,s5,s6;</span><br><span class="line">	s1=(f[n<span class="number">-1</span>][<span class="number">0</span>]-(n<span class="number">-1</span>)*f[n<span class="number">-2</span>][<span class="number">0</span>]/n).a;</span><br><span class="line">	s2=(f[n<span class="number">-1</span>][<span class="number">0</span>]-(n<span class="number">-1</span>)*f[n<span class="number">-2</span>][<span class="number">0</span>]/n).b;</span><br><span class="line">	s3=(f[n<span class="number">-1</span>][<span class="number">0</span>]-(n<span class="number">-1</span>)*f[n<span class="number">-2</span>][<span class="number">0</span>]/n).c;</span><br><span class="line">	s4=(f[n<span class="number">-1</span>][<span class="number">1</span>]-(n<span class="number">-2</span>)*f[n<span class="number">-2</span>][<span class="number">1</span>]/n-f[n<span class="number">-2</span>][<span class="number">0</span>]/n-ny[n]).a;</span><br><span class="line">	s5=(f[n<span class="number">-1</span>][<span class="number">1</span>]-(n<span class="number">-2</span>)*f[n<span class="number">-2</span>][<span class="number">1</span>]/n-f[n<span class="number">-2</span>][<span class="number">0</span>]/n-ny[n]).b;</span><br><span class="line">	s6=(f[n<span class="number">-1</span>][<span class="number">1</span>]-(n<span class="number">-2</span>)*f[n<span class="number">-2</span>][<span class="number">1</span>]/n-f[n<span class="number">-2</span>][<span class="number">0</span>]/n-ny[n]).c;</span><br><span class="line">	ll x,y;</span><br><span class="line">	s2*=s4,s2-=s1*s5,s2%=mod,s2+=mod,s2%=mod,s3*=s4,s3-=s1*s6,s3%=mod,s3+=mod,s3%=mod;</span><br><span class="line">	y=s3*<span class="built_in">qkp</span>(s2,mod<span class="number">-2</span>)%mod,y=(mod-y)%mod;</span><br><span class="line">	s6=mod-(s6+s5*y)%mod;</span><br><span class="line">	s6%=mod;</span><br><span class="line">	x=s6*<span class="built_in">qkp</span>(s4,mod<span class="number">-2</span>)%mod;<span class="comment">//直接暴力解二元方程组</span></span><br><span class="line">	ll a[<span class="number">2</span>];</span><br><span class="line">	a[<span class="number">0</span>]=f[cnt][<span class="number">0</span>].<span class="built_in">val</span>(x,y),a[<span class="number">1</span>]=f[cnt][<span class="number">1</span>].<span class="built_in">val</span>(x,y);</span><br><span class="line">	a[<span class="number">0</span>]+=ny[n],a[<span class="number">0</span>]%=mod,a[<span class="number">1</span>]+=ny[n],a[<span class="number">1</span>]%=mod;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[i]==<span class="string">&#x27;1&#x27;</span>)ans=(ans+a[<span class="number">1</span>]*dis[i+<span class="number">1</span>])%mod;</span><br><span class="line">		<span class="keyword">else</span> ans=(ans+a[<span class="number">0</span>]*dis[i+<span class="number">1</span>])%mod;</span><br><span class="line">	&#125;<span class="comment">//统计答案</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>由于选点是随机的，因此树上路径长与点的翻转其实是独立的。因此我们把问题分成两部分来解决。</p>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>礼物购买</title>
    <url>/2022/02/13/%E7%A4%BC%E7%89%A9%E8%B4%AD%E4%B9%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2022/02/13/%E7%A4%BC%E7%89%A9%E8%B4%AD%E4%B9%B0/1.png"></p>
<p>$n\le 3000,m\le 300$</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>肯定是要算贡献的。</p>
<p>考察一个礼物的贡献，用 $g_{i,j}$ 表示其贡献，即：第 $i$ 种礼物有 $j$ 个，期望被拿走的个数。</p>
<p>考虑从 $g_{i,j}$ 转移到 $g_{i,j+1}$，发现这取决于喜欢这种礼物的人数。考虑有 $k$ 个人喜欢这种礼物的概率，用 $h_{i,j,k}$ 表示前 $j$ 个人中有 $k$ 个人喜欢 $i$ 礼物的概率。此时 $g_{i,j}=\sum_{x=0}^{n}\min (x,j)h_{i,n,x}$，进而 $g_{i,j}-g_{i,j-1}=\sum_{x=j}^nh_{i,n,x}$。</p>
<p>进而买 $j$ 件前 $i$ 种礼物的期望值为：$f_{i,j}=\max(f_{i-1,j-x}+g_{i,x})$。发现 $g$ 的差分不增，故可以转换为贪心，每次寻找 $g$ 增量最大的种类。</p>
<p>此时瓶颈在于求 $h$。<br>$$<br>h_{i,j,k}=(1-p)h_{i,j-1,k}+ph_{i,j-1,k-1}<br>$$<br>发现我们每次用一个 $\Delta g$ 更新后，只需知道 $\sum_{x=j}^nh_{i,n,x}$，而之前一定已经求过 $\sum_{x=j-1}^nh_{i,n,x}$，故只需求 $h_{i,n,j-1}$，而此前必求过 $h_{i,n,j-2}$，故可以递推，并不需要知道全部 $h$。</p>
<p>复杂度是对的。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt[<span class="number">301</span>];</span><br><span class="line"><span class="type">double</span> p[<span class="number">3001</span>][<span class="number">301</span>],g[<span class="number">301</span>],h[<span class="number">301</span>][<span class="number">3001</span>][<span class="number">2</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;y;i++)h[x][i][y&amp;<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(y,<span class="number">1</span>);i&lt;=n;i++)</span><br><span class="line">	h[x][i][y&amp;<span class="number">1</span>]=h[x][i<span class="number">-1</span>][(y&amp;<span class="number">1</span>)^<span class="number">1</span>]*p[i][x]+h[x][i<span class="number">-1</span>][y&amp;<span class="number">1</span>]*(<span class="number">1.0</span>-p[i][x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;coin.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;coin.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">		<span class="type">int</span> _;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);p[i][j]=<span class="number">0.001</span>*_;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)h[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">upd</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[i]=<span class="number">1</span>-h[i][n][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> _=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;j++)<span class="keyword">if</span>(g[j]&gt;g[_])_=j;</span><br><span class="line">		ans+=g[_];</span><br><span class="line">		<span class="built_in">upd</span>(_,++cnt[_]);g[_]-=h[_][n][cnt[_]&amp;<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>发现问题的性质。</p>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>期望</tag>
      </tags>
  </entry>
</search>
